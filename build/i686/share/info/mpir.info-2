This is mpir.info, produced by makeinfo version 5.2 from mpir.texi.

This manual describes how to install and use MPIR, the Multiple
Precision Integers and Rationals library, version 3.0.0.

   Copyright 1991, 1993-2016 Free Software Foundation, Inc.

   Copyright 2008, 2009, 2010 William Hart

   Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover Texts being "A GNU Manual", and
with the Back-Cover Texts being "You have freedom to copy and modify
this GNU Manual, like GNU software".  A copy of the license is included
in *note GNU Free Documentation License::.
INFO-DIR-SECTION GNU libraries
START-INFO-DIR-ENTRY
* mpir: (mpir).                   MPIR Multiple Precision Integers and Rationals Library.
END-INFO-DIR-ENTRY


File: mpir.info,  Node: MPIR.Net Settings,  Prev: MPIR.Net Random Numbers,  Up: .Net Interface

13.7 MPIR.Net Settings
======================

 -- Static Class: MpirSettings
     This static class contains several members that describe or control
     various default behaviors of the other MPIR.Net classes.

 -- Constant: int BITS_PER_LIMB
     Represents the total number of bits in a single MPIR limb,
     including data bits and nail bits.  This will be either 32 or 64,
     depending on your selected build architecture.

 -- Constant: int NAIL_BITS_PER_LIMB
     Represents the number of nail bits in a single MPIR limb.  Nail
     bits are used internally by MPIR.

 -- Constant: int USABLE_BITS_PER_LIMB
     Represents the number of data bits in a single MPIR limb.

 -- Constant: Version MPIR_VERSION
     Represents the version of the underlying MPIR library

 -- Constant: Version GMP_VERSION
     Represents the version of GMP with which the underlying MPIR
     library is compatible

 -- Static Property: RoundingModes RoundingMode
     Gets or sets the default rounding mode used for MPIR integer
     division operations that don't explicitly specify a rounding mode.
     Does not affect rational or float operations.  The default value is
     'Truncate'.

 -- Static Property: int ToStringDigits
     Gets or sets the maximum number of digits the 'object.ToString()'
     method override will output.  If an integer number is longer than
     this number of digits, it will be output as "'[-]...NNNNN'" with
     the least significant digits shown.  Rational numbers apply the
     limit separately to the numerator and denominator.  Floats output
     the most significant digits, and there is no ellipsis.

     The primary purpose of this setting is to prevent accidental
     allocation of large memory blocks while inspecting variables in the
     debugger.  The default value is 256.  Setting this property to 0
     causes all digits to be output.


File: mpir.info,  Node: Custom Allocation,  Next: Language Bindings,  Prev: .Net Interface,  Up: Top

14 Custom Allocation
********************

By default MPIR uses 'malloc', 'realloc' and 'free' for memory
allocation, and if they fail MPIR prints a message to the standard error
output and terminates the program.

   Alternate functions can be specified, to allocate memory in a
different way or to have a different error action on running out of
memory.

 -- Function: void mp_set_memory_functions (
          void *(*ALLOC_FUNC_PTR) (size_t),
          void *(*REALLOC_FUNC_PTR) (void *, size_t, size_t),
          void (*FREE_FUNC_PTR) (void *, size_t))
     Replace the current allocation functions from the arguments.  If an
     argument is 'NULL', the corresponding default function is used.

     These functions will be used for all memory allocation done by
     MPIR, apart from temporary space from 'alloca' if that function is
     available and MPIR is configured to use it (*note Build Options::).

     *Be sure to call 'mp_set_memory_functions' only when there are no
     active MPIR objects allocated using the previous memory functions!
     Usually that means calling it before any other MPIR function.*

   The functions supplied should fit the following declarations:

 -- Function: void * allocate_function (size_t ALLOC_SIZE)
     Return a pointer to newly allocated space with at least ALLOC_SIZE
     bytes.

 -- Function: void * reallocate_function (void *PTR, size_t OLD_SIZE,
          size_t NEW_SIZE)
     Resize a previously allocated block PTR of OLD_SIZE bytes to be
     NEW_SIZE bytes.

     The block may be moved if necessary or if desired, and in that case
     the smaller of OLD_SIZE and NEW_SIZE bytes must be copied to the
     new location.  The return value is a pointer to the resized block,
     that being the new location if moved or just PTR if not.

     PTR is never 'NULL', it's always a previously allocated block.
     NEW_SIZE may be bigger or smaller than OLD_SIZE.

 -- Function: void free_function (void *PTR, size_t SIZE)
     De-allocate the space pointed to by PTR.

     PTR is never 'NULL', it's always a previously allocated block of
     SIZE bytes.

   A "byte" here means the unit used by the 'sizeof' operator.

   The OLD_SIZE parameters to REALLOCATE_FUNCTION and FREE_FUNCTION are
passed for convenience, but of course can be ignored if not needed.  The
default functions using 'malloc' and friends for instance don't use
them.

   No error return is allowed from any of these functions, if they
return then they must have performed the specified operation.  In
particular note that ALLOCATE_FUNCTION or REALLOCATE_FUNCTION mustn't
return 'NULL'.

   Getting a different fatal error action is a good use for custom
allocation functions, for example giving a graphical dialog rather than
the default print to 'stderr'.  How much is possible when genuinely out
of memory is another question though.

   There's currently no defined way for the allocation functions to
recover from an error such as out of memory, they must terminate program
execution.  A 'longjmp' or throwing a C++ exception will have undefined
results.  This may change in the future.

   MPIR may use allocated blocks to hold pointers to other allocated
blocks.  This will limit the assumptions a conservative garbage
collection scheme can make.

   Any custom allocation functions must align pointers to limb
boundaries.  Thus if a limb is eight bytes (e.g.  on x86_64), then all
blocks must be aligned to eight byte boundaries.  Check the
configuration options for the custom allocation library in use.  It is
not necessary to align blocks to SSE boundaries even when SSE code is
used.  All MPIR assembly routines assume limb boundary alignment only
(which is the default for most standard memory managers).

   Since the default MPIR allocation uses 'malloc' and friends, those
functions will be linked in even if the first thing a program does is an
'mp_set_memory_functions'.  It's necessary to change the MPIR sources if
this is a problem.


 -- Function: void mp_get_memory_functions (
          void *(**ALLOC_FUNC_PTR) (size_t),
          void *(**REALLOC_FUNC_PTR) (void *, size_t, size_t),
          void (**FREE_FUNC_PTR) (void *, size_t))
     Get the current allocation functions, storing function pointers to
     the locations given by the arguments.  If an argument is 'NULL',
     that function pointer is not stored.

     For example, to get just the current free function,

          void (*freefunc) (void *, size_t);

          mp_get_memory_functions (NULL, NULL, &freefunc);


File: mpir.info,  Node: Language Bindings,  Next: Algorithms,  Prev: Custom Allocation,  Up: Top

15 Language Bindings
********************

The following packages and projects offer access to MPIR from languages
other than C, though perhaps with varying levels of functionality and
efficiency.


C++
        * MPIR C++ class interface, *note C++ Class Interface::
          Straightforward interface, expression templates to eliminate
          temporaries.
        * ALP <http://www-sop.inria.fr/saga/logiciels/ALP/>
          Linear algebra and polynomials using templates.
        * CLN <http://www.ginac.de/CLN/>
          High level classes for arithmetic.
        * LiDIA <http://www.informatik.tu-darmstadt.de/TI/LiDIA/>
          A C++ library for computational number theory.
        * Linbox <http://www.linalg.org/>
          Sparse vectors and matrices.
        * NTL <http://www.shoup.net/ntl/>
          A C++ number theory library.

Eiffel
        * Eiffel Interface <http://www.eiffelroom.org/node/407>
          An Eiffel Interface to MPFR, MPC and MPIR by Chris Saunders.

Fortran
        * Omni F77 <http://phase.hpcc.jp/Omni/home.html>
          Arbitrary precision floats.

Haskell
        * Glasgow Haskell Compiler <http://www.haskell.org/ghc/>

Java
        * Kaffe <http://www.kaffe.org/>

Lisp
        * Embeddable Common Lisp
          <http://ecls.sourceforge.net/download.html>
        * GNU Common Lisp <http://www.gnu.org/software/gcl/gcl.html>
        * Librep <http://librep.sourceforge.net/>
        * XEmacs (21.5.18 beta and up) <http://www.xemacs.org>
          Optional big integers, rationals and floats using MPIR.

M4
        * GNU m4 betas <http://www.seindal.dk/rene/gnu/>
          Optionally provides an arbitrary precision 'mpeval'.

ML
        * MLton compiler <http://mlton.org/>

Objective Caml
        * Numerix <http://pauillac.inria.fr/~quercia/>
          Optionally using GMP.

Oz
        * Mozart <http://www.mozart-oz.org/>

Pascal
        * GNU Pascal Compiler <http://www.gnu-pascal.de/>
          GMP unit.
        * Numerix <http://pauillac.inria.fr/~quercia/>
          For Free Pascal, optionally using GMP.

Perl
        * GMP module, see 'demos/perl' on the MPIR website.
        * Math::GMP <http://www.cpan.org/>
          Compatible with Math::BigInt, but not as many functions as the
          GMP module above.
        * Math::BigInt::GMP <http://www.cpan.org/>
          Plug Math::GMP into normal Math::BigInt operations.

PHP
        * mpz module in the main distribution, <http://php.net/>

Pike
        * mpz module in the standard distribution,
          <http://pike.ida.liu.se/>

Prolog
        * SWI Prolog <http://www.swi-prolog.org/>
          Arbitrary precision floats.

Python
        * mpz module in the standard distribution,
          <http://www.python.org/>
        * GMPY <http://gmpy.sourceforge.net/>

Scheme
        * GNU Guile (upcoming 1.8)
          <http://www.gnu.org/software/guile/guile.html>
        * RScheme <http://www.rscheme.org/>

Smalltalk
        * GNU Smalltalk
          <http://www.smalltalk.org/versions/GNUSmalltalk.html>

Other
        * ALGLIB <http://www.alglib.net/>
          Numerical analysis and data processing library.
        * Axiom <http://savannah.nongnu.org/projects/axiom>
          Computer algebra using GCL.
        * GiNaC <http://www.ginac.de/>
          C++ computer algebra using CLN.
        * GOO <http://www.googoogaga.org/>
          Dynamic object oriented language.
        * Maxima <http://www.ma.utexas.edu/users/wfs/maxima.html>
          Macsyma computer algebra using GCL.
        * Q <http://q-lang.sourceforge.net/>
          Equational programming system.
        * Regina <http://regina.sourceforge.net/>
          Topological calculator.
        * Sage <http://www.sagemath.org/>
          Computer Algebra System written in Python and Cython.
        * Yacas <http://yacas.sourceforge.net/homepage.html>
          Yet another computer algebra system.


File: mpir.info,  Node: Algorithms,  Next: Internals,  Prev: Language Bindings,  Up: Top

16 Algorithms
*************

This chapter is an introduction to some of the algorithms used for
various MPIR operations.  The code is likely to be hard to understand
without knowing something about the algorithms.

   Some MPIR internals are mentioned, but applications that expect to be
compatible with future MPIR releases should take care to use only the
documented functions.

* Menu:

* Multiplication Algorithms::
* Division Algorithms::
* Greatest Common Divisor Algorithms::
* Powering Algorithms::
* Root Extraction Algorithms::
* Radix Conversion Algorithms::
* Other Algorithms::
* Assembler Coding::


File: mpir.info,  Node: Multiplication Algorithms,  Next: Division Algorithms,  Prev: Algorithms,  Up: Algorithms

16.1 Multiplication
===================

NxN limb multiplications and squares are done using one of six
algorithms, as the size N increases.

     Algorithm      Mul Threshold
     Basecase       (none)
     Karatsuba      'MUL_KARATSUBA_THRESHOLD'
     Toom-3         'MUL_TOOM3_THRESHOLD'
     Toom-4         'MUL_TOOM4_THRESHOLD'
     Toom-8(.5)     'MUL_TOOM8H_THRESHOLD'
     FFT            'MUL_FFT_FULL_THRESHOLD'

     Algorithm      Sqr Threshold
     Basecase       (none)
     Karatsuba      'SQR_KARATSUBA_THRESHOLD'
     Toom-3         'SQR_TOOM3_THRESHOLD'
     Toom-4         'SQR_TOOM4_THRESHOLD'
     Toom-8         'SQR_TOOM8_THRESHOLD'
     FFT            'SQR_FFT_FULL_THRESHOLD'

   NxM multiplications of operands with different sizes above
'MUL_KARATSUBA_THRESHOLD' are done using unbalanced Toom algorithms or
with the FFT. See (*note Unbalanced Multiplication::).

* Menu:

* Basecase Multiplication::
* Karatsuba Multiplication::
* Toom 3-Way Multiplication::
* Toom 4-Way Multiplication::
* FFT Multiplication::
* Other Multiplication::
* Unbalanced Multiplication::


File: mpir.info,  Node: Basecase Multiplication,  Next: Karatsuba Multiplication,  Prev: Multiplication Algorithms,  Up: Multiplication Algorithms

16.1.1 Basecase Multiplication
------------------------------

Basecase NxM multiplication is a straightforward rectangular set of
cross-products, the same as long multiplication done by hand and for
that reason sometimes known as the schoolbook or grammar school method.
This is an O(N*M) algorithm.  See Knuth section 4.3.1 algorithm M (*note
References::), and the 'mpn/generic/mul_basecase.c' code.

   Assembler implementations of 'mpn_mul_basecase' are essentially the
same as the generic C code, but have all the usual assembler tricks and
obscurities introduced for speed.

   A square can be done in roughly half the time of a multiply, by using
the fact that the cross products above and below the diagonal are the
same.  A triangle of products below the diagonal is formed, doubled
(left shift by one bit), and then the products on the diagonal added.
This can be seen in 'mpn/generic/sqr_basecase.c'.  Again the assembler
implementations take essentially the same approach.

          u0  u1  u2  u3  u4
        +---+---+---+---+---+
     u0 | d |   |   |   |   |
        +---+---+---+---+---+
     u1 |   | d |   |   |   |
        +---+---+---+---+---+
     u2 |   |   | d |   |   |
        +---+---+---+---+---+
     u3 |   |   |   | d |   |
        +---+---+---+---+---+
     u4 |   |   |   |   | d |
        +---+---+---+---+---+

   In practice squaring isn't a full 2x faster than multiplying, it's
usually around 1.5x.  Less than 1.5x probably indicates
'mpn_sqr_basecase' wants improving on that CPU.

   On some CPUs 'mpn_mul_basecase' can be faster than the generic C
'mpn_sqr_basecase' on some small sizes.  'SQR_BASECASE_THRESHOLD' is the
size at which to use 'mpn_sqr_basecase', this will be zero if that
routine should be used always.


File: mpir.info,  Node: Karatsuba Multiplication,  Next: Toom 3-Way Multiplication,  Prev: Basecase Multiplication,  Up: Multiplication Algorithms

16.1.2 Karatsuba Multiplication
-------------------------------

The Karatsuba multiplication algorithm is described in Knuth section
4.3.3 part A, and various other textbooks.  A brief description is given
here.

   The inputs x and y are treated as each split into two parts of equal
length (or the most significant part one limb shorter if N is odd).

      high              low
     +----------+----------+
     |    x1    |    x0    |
     +----------+----------+

     +----------+----------+
     |    y1    |    y0    |
     +----------+----------+

   Let b be the power of 2 where the split occurs, ie. if x0 is k limbs
(y0 the same) then b=2^(k*mp_bits_per_limb).  With that x=x1*b+x0 and
y=y1*b+y0, and the following holds,

     x*y = (b^2+b)*x1*y1 - b*(x1-x0)*(y1-y0) + (b+1)*x0*y0

   This formula means doing only three multiplies of (N/2)x(N/2) limbs,
whereas a basecase multiply of NxN limbs is equivalent to four
multiplies of (N/2)x(N/2).  The factors (b^2+b) etc represent the
positions where the three products must be added.

      high                              low
     +--------+--------+ +--------+--------+
     |      x1*y1      | |      x0*y0      |
     +--------+--------+ +--------+--------+
               +--------+--------+
           add |      x1*y1      |
               +--------+--------+
               +--------+--------+
           add |      x0*y0      |
               +--------+--------+
               +--------+--------+
           sub | (x1-x0)*(y1-y0) |
               +--------+--------+

   The term (x1-x0)*(y1-y0) is best calculated as an absolute value, and
the sign used to choose to add or subtract.  Notice the sum
high(x0*y0)+low(x1*y1) occurs twice, so it's possible to do 5*k limb
additions, rather than 6*k, but in MPIR extra function call overheads
outweigh the saving.

   Squaring is similar to multiplying, but with x=y the formula reduces
to an equivalent with three squares,

     x^2 = (b^2+b)*x1^2 - b*(x1-x0)^2 + (b+1)*x0^2

   The final result is accumulated from those three squares the same way
as for the three multiplies above.  The middle term (x1-x0)^2 is now
always positive.

   A similar formula for both multiplying and squaring can be
constructed with a middle term (x1+x0)*(y1+y0).  But those sums can
exceed k limbs, leading to more carry handling and additions than the
form above.

   Karatsuba multiplication is asymptotically an O(N^1.585) algorithm,
the exponent being log(3)/log(2), representing 3 multiplies each 1/2 the
size of the inputs.  This is a big improvement over the basecase
multiply at O(N^2) and the advantage soon overcomes the extra additions
Karatsuba performs.  'MUL_KARATSUBA_THRESHOLD' can be as little as 10
limbs.  The 'SQR' threshold is usually about twice the 'MUL'.

   The basecase algorithm will take a time of the form M(N) = a*N^2 +
b*N + c and the Karatsuba algorithm K(N) = 3*M(N/2) + d*N + e, which
expands to K(N) = 3/4*a*N^2 + 3/2*b*N + 3*c + d*N + e.  The factor 3/4
for a means per-crossproduct speedups in the basecase code will increase
the threshold since they benefit M(N) more than K(N).  And conversely
the 3/2 for b means linear style speedups of b will increase the
threshold since they benefit K(N) more than M(N).  The latter can be
seen for instance when adding an optimized 'mpn_sqr_diagonal' to
'mpn_sqr_basecase'.  Of course all speedups reduce total time, and in
that sense the algorithm thresholds are merely of academic interest.


File: mpir.info,  Node: Toom 3-Way Multiplication,  Next: Toom 4-Way Multiplication,  Prev: Karatsuba Multiplication,  Up: Multiplication Algorithms

16.1.3 Toom 3-Way Multiplication
--------------------------------

The Karatsuba formula is the simplest case of a general approach to
splitting inputs that leads to both Toom and FFT algorithms.  A
description of Toom can be found in Knuth section 4.3.3, with an example
3-way calculation after Theorem A.  The 3-way form used in MPIR is
described here.

   The operands are each considered split into 3 pieces of equal length
(or the most significant part 1 or 2 limbs shorter than the other two).

      high                         low
     +----------+----------+----------+
     |    x2    |    x1    |    x0    |
     +----------+----------+----------+

     +----------+----------+----------+
     |    y2    |    y1    |    y0    |
     +----------+----------+----------+

These parts are treated as the coefficients of two polynomials

     X(t) = x2*t^2 + x1*t + x0
     Y(t) = y2*t^2 + y1*t + y0

   Let b equal the power of 2 which is the size of the x0, x1, y0 and y1
pieces, ie. if they're k limbs each then b=2^(k*mp_bits_per_limb).  With
this x=X(b) and y=Y(b).

   Let a polynomial W(t)=X(t)*Y(t) and suppose its coefficients are

     W(t) = w4*t^4 + w3*t^3 + w2*t^2 + w1*t + w0

   The w[i] are going to be determined, and when they are they'll give
the final result using w=W(b), since x*y=X(b)*Y(b)=W(b).  The
coefficients will be roughly b^2 each, and the final W(b) will be an
addition like,

      high                                        low
     +-------+-------+
     |       w4      |
     +-------+-------+
            +--------+-------+
            |        w3      |
            +--------+-------+
                    +--------+-------+
                    |        w2      |
                    +--------+-------+
                            +--------+-------+
                            |        w1      |
                            +--------+-------+
                                     +-------+-------+
                                     |       w0      |
                                     +-------+-------+

   The w[i] coefficients could be formed by a simple set of cross
products, like w4=x2*y2, w3=x2*y1+x1*y2, w2=x2*y0+x1*y1+x0*y2 etc, but
this would need all nine x[i]*y[j] for i,j=0,1,2, and would be
equivalent merely to a basecase multiply.  Instead the following
approach is used.

   X(t) and Y(t) are evaluated and multiplied at 5 points, giving values
of W(t) at those points.  In MPIR the following points are used,

     Point    Value
     t=0      x0 * y0, which gives w0 immediately
     t=1      (x2+x1+x0) * (y2+y1+y0)
     t=-1     (x2-x1+x0) * (y2-y1+y0)
     t=2      (4*x2+2*x1+x0) * (4*y2+2*y1+y0)
     t=inf    x2 * y2, which gives w4 immediately

   At t=-1 the values can be negative and that's handled using the
absolute values and tracking the sign separately.  At t=inf the value is
actually X(t)*Y(t)/t^4 in the limit as t approaches infinity, but it's
much easier to think of as simply x2*y2 giving w4 immediately (much like
x0*y0 at t=0 gives w0 immediately).

   Each of the points substituted into W(t)=w4*t^4+...+w0 gives a linear
combination of the w[i] coefficients, and the value of those
combinations has just been calculated.

     W(0)   =                              w0
     W(1)   =    w4 +   w3 +   w2 +   w1 + w0
     W(-1)  =    w4 -   w3 +   w2 -   w1 + w0
     W(2)   = 16*w4 + 8*w3 + 4*w2 + 2*w1 + w0
     W(inf) =    w4

   This is a set of five equations in five unknowns, and some elementary
linear algebra quickly isolates each w[i].  This involves adding or
subtracting one W(t) value from another, and a couple of divisions by
powers of 2 and one division by 3, the latter using the special
'mpn_divexact_by3' (*note Exact Division::).

   The conversion of W(t) values to the coefficients is interpolation.
A polynomial of degree 4 like W(t) is uniquely determined by values
known at 5 different points.  The points are arbitrary and can be chosen
to make the linear equations come out with a convenient set of steps for
quickly isolating the w[i].

   Squaring follows the same procedure as multiplication, but there's
only one X(t) and it's evaluated at the 5 points, and those values
squared to give values of W(t).  The interpolation is then identical,
and in fact the same 'toom3_interpolate' subroutine is used for both
squaring and multiplying.

   Toom-3 is asymptotically O(N^1.465), the exponent being
log(5)/log(3), representing 5 recursive multiplies of 1/3 the original
size each.  This is an improvement over Karatsuba at O(N^1.585), though
Toom does more work in the evaluation and interpolation and so it only
realizes its advantage above a certain size.

   Near the crossover between Toom-3 and Karatsuba there's generally a
range of sizes where the difference between the two is small.
'MUL_TOOM3_THRESHOLD' is a somewhat arbitrary point in that range and
successive runs of the tune program can give different values due to
small variations in measuring.  A graph of time versus size for the two
shows the effect, see 'tune/README'.

   At the fairly small sizes where the Toom-3 thresholds occur it's
worth remembering that the asymptotic behaviour for Karatsuba and Toom-3
can't be expected to make accurate predictions, due of course to the big
influence of all sorts of overheads, and the fact that only a few
recursions of each are being performed.  Even at large sizes there's a
good chance machine dependent effects like cache architecture will mean
actual performance deviates from what might be predicted.

   The formula given for the Karatsuba algorithm (*note Karatsuba
Multiplication::) has an equivalent for Toom-3 involving only five
multiplies, but this would be complicated and unenlightening.

   An alternate view of Toom-3 can be found in Zuras (*note
References::), using a vector to represent the x and y splits and a
matrix multiplication for the evaluation and interpolation stages.  The
matrix inverses are not meant to be actually used, and they have
elements with values much greater than in fact arise in the
interpolation steps.  The diagram shown for the 3-way is attractive, but
again doesn't have to be implemented that way and for example with a bit
of rearrangement just one division by 6 can be done.


File: mpir.info,  Node: Toom 4-Way Multiplication,  Next: FFT Multiplication,  Prev: Toom 3-Way Multiplication,  Up: Multiplication Algorithms

16.1.4 Toom 4-Way Multiplication
--------------------------------

Karatsuba and Toom-3 split the operands into 2 and 3 coefficients,
respectively.  Toom-4 analogously splits the operands into 4
coefficients.  Using the notation from the section on Toom-3
multiplication, we form two polynomials:

     X(t) = x3*t^3 + x2*t^2 + x1*t + x0
     Y(t) = y3*t^3 + y2*t^2 + y1*t + y0

   X(t) and Y(t) are evaluated and multiplied at 7 points, giving values
of W(t) at those points.  In MPIR the following points are used,

     Point    Value
     t=0      x0 * y0, which gives w0 immediately
     t=1/2    (x3+2*x2+4*x1+8*x0) * (y3+2*y2+4*y1+8*y0)
     t=-1/2   (-x3+2*x2-4*x1+8*x0) * (-y3+2*y2-4*y1+8*y0)
     t=1      (x3+x2+x1+x0) * (y3+y2+y1+y0)
     t=-1     (-x3+x2-x1+x0) * (-y3+y2-y1+y0)
     t=2      (8*x3+4*x2+2*x1+x0) * (8*y3+4*y2+2*y1+y0)
     t=inf    x3 * y3, which gives w6 immediately

   The number of additions and subtractions for Toom-4 is much larger
than for Toom-3.  But several subexpressions occur multiple times, for
example x2+x0, occurs for both t=1 and t=-1.

   Toom-4 is asymptotically O(N^1.404), the exponent being
log(7)/log(4), representing 7 recursive multiplies of 1/4 the original
size each.


File: mpir.info,  Node: FFT Multiplication,  Next: Other Multiplication,  Prev: Toom 4-Way Multiplication,  Up: Multiplication Algorithms

16.1.5 FFT Multiplication
-------------------------

This section is out-of-date and will be updated when the new FFT is
added.

   At large to very large sizes a Fermat style FFT multiplication is
used, following Scho"nhage and Strassen (*note References::).
Descriptions of FFTs in various forms can be found in many textbooks,
for instance Knuth section 4.3.3 part C or Lipson chapter IX.  A brief
description of the form used in MPIR is given here.

   The multiplication done is x*y mod 2^N+1, for a given N.  A full
product x*y is obtained by choosing N>=bits(x)+bits(y) and padding x and
y with high zero limbs.  The modular product is the native form for the
algorithm, so padding to get a full product is unavoidable.

   The algorithm follows a split, evaluate, pointwise multiply,
interpolate and combine similar to that described above for Karatsuba
and Toom-3.  A k parameter controls the split, with an FFT-k splitting
into 2^k pieces of M=N/2^k bits each.  N must be a multiple of
(2^k)*mp_bits_per_limb so the split falls on limb boundaries, avoiding
bit shifts in the split and combine stages.

   The evaluations, pointwise multiplications, and interpolation, are
all done modulo 2^N'+1 where N' is 2M+k+3 rounded up to a multiple of
2^k and of 'mp_bits_per_limb'.  The results of interpolation will be the
following negacyclic convolution of the input pieces, and the choice of
N' ensures these sums aren't truncated.

                ---
                \         b
     w[n] =     /     (-1) * x[i] * y[j]
                ---
            i+j==b*2^k+n
               b=0,1

   The points used for the evaluation are g^i for i=0 to 2^k-1 where
g=2^(2N'/2^k).  g is a 2^k'th root of unity mod 2^N'+1, which produces
necessary cancellations at the interpolation stage, and it's also a
power of 2 so the fast fourier transforms used for the evaluation and
interpolation do only shifts, adds and negations.

   The pointwise multiplications are done modulo 2^N'+1 and either
recurse into a further FFT or use a plain multiplication (Toom-3,
Karatsuba or basecase), whichever is optimal at the size N'.  The
interpolation is an inverse fast fourier transform.  The resulting set
of sums of x[i]*y[j] are added at appropriate offsets to give the final
result.

   Squaring is the same, but x is the only input so it's one transform
at the evaluate stage and the pointwise multiplies are squares.  The
interpolation is the same.

   For a mod 2^N+1 product, an FFT-k is an O(N^(k/(k-1))) algorithm, the
exponent representing 2^k recursed modular multiplies each 1/2^(k-1) the
size of the original.  Each successive k is an asymptotic improvement,
but overheads mean each is only faster at bigger and bigger sizes.  In
the code, 'MUL_FFT_TABLE' and 'SQR_FFT_TABLE' are the thresholds where
each k is used.  Each new k effectively swaps some multiplying for some
shifts, adds and overheads.

   A mod 2^N+1 product can be formed with a normal NxN->2N bit multiply
plus a subtraction, so an FFT and Toom-3 etc can be compared directly.
A k=4 FFT at O(N^1.333) can be expected to be the first faster than
Toom-3 at O(N^1.465).  In practice this is what's found, with
'MUL_FFT_MODF_THRESHOLD' and 'SQR_FFT_MODF_THRESHOLD' being between 300
and 1000 limbs, depending on the CPU.  So far it's been found that only
very large FFTs recurse into pointwise multiplies above these sizes.

   When an FFT is to give a full product, the change of N to 2N doesn't
alter the theoretical complexity for a given k, but for the purposes of
considering where an FFT might be first used it can be assumed that the
FFT is recursing into a normal multiply and that on that basis it's
doing 2^k recursed multiplies each 1/2^(k-2) the size of the inputs,
making it O(N^(k/(k-2))).  This would mean k=7 at O(N^1.4) would be the
first FFT faster than Toom-3.  In practice 'MUL_FFT_FULL_THRESHOLD' and
'SQR_FFT_FULL_THRESHOLD' have been found to be in the k=8 range,
somewhere between 3000 and 10000 limbs.

   The way N is split into 2^k pieces and then 2M+k+3 is rounded up to a
multiple of 2^k and 'mp_bits_per_limb' means that when
2^k>=mp\_bits\_per\_limb the effective N is a multiple of 2^(2k-1) bits.
The +k+3 means some values of N just under such a multiple will be
rounded to the next.  The complexity calculations above assume that a
favourable size is used, meaning one which isn't padded through
rounding, and it's also assumed that the extra +k+3 bits are negligible
at typical FFT sizes.

   The practical effect of the 2^(2k-1) constraint is to introduce a
step-effect into measured speeds.  For example k=8 will round N up to a
multiple of 32768 bits, so for a 32-bit limb there'll be 512 limb groups
of sizes for which 'mpn_mul_n' runs at the same speed.  Or for k=9
groups of 2048 limbs, k=10 groups of 8192 limbs, etc.  In practice it's
been found each k is used at quite small multiples of its size
constraint and so the step effect is quite noticeable in a time versus
size graph.

   The threshold determinations currently measure at the mid-points of
size steps, but this is sub-optimal since at the start of a new step it
can happen that it's better to go back to the previous k for a while.
Something more sophisticated for 'MUL_FFT_TABLE' and 'SQR_FFT_TABLE'
will be needed.


File: mpir.info,  Node: Other Multiplication,  Next: Unbalanced Multiplication,  Prev: FFT Multiplication,  Up: Multiplication Algorithms

16.1.6 Other Multiplication
---------------------------

The Toom algorithms described above (*note Toom 3-Way Multiplication::),
*note Toom 4-Way Multiplication::) generalize to split into an arbitrary
number of pieces, as per Knuth section 4.3.3 algorithm C.  MPIR
currently implements Toom 8 routines.

   These are generated automatically via a technique due to Bodrato
(*note References::) which mixes evaluation, pointwise multiplication
and interpolation phases.  The routine used is called Toom 8.5.  See
Bodrato's paper.

   For general Toom-n a split into r+1 pieces is made, and evaluations
and pointwise multiplications done at 2*r+1 points.  A 4-way split does
7 pointwise multiplies, 5-way does 9, etc.  Asymptotically an (r+1)-way
algorithm is O(N^(log(2*r+1)/log(r+1))).  Only the pointwise
multiplications count towards big-O complexity, but the time spent in
the evaluate and interpolate stages grows with r and has a significant
practical impact, with the asymptotic advantage of each r realized only
at bigger and bigger sizes.  The overheads grow as O(N*r), whereas in an
r=2^k FFT they grow only as O(N*log(r)).

   Knuth algorithm C evaluates at points 0,1,2,...,2*r, but exercise 4
uses -r,...,0,...,r and the latter saves some small multiplies in the
evaluate stage (or rather trades them for additions), and has a further
saving of nearly half the interpolate steps.  The idea is to separate
odd and even final coefficients and then perform algorithm C steps C7
and C8 on them separately.  The divisors at step C7 become j^2 and the
multipliers at C8 become 2*t*j-j^2.

   Splitting odd and even parts through positive and negative points can
be thought of as using -1 as a square root of unity.  If a 4th root of
unity was available then a further split and speedup would be possible,
but no such root exists for plain integers.  Going to complex integers
with i=sqrt(-1) doesn't help, essentially because in cartesian form it
takes three real multiplies to do a complex multiply.  The existence of
2^k'th roots of unity in a suitable ring or field lets the fast fourier
transform keep splitting and get to O(N*log(r)).

   Floating point FFTs use complex numbers approximating Nth roots of
unity.  Some processors have special support for such FFTs.  But these
are not used in MPIR since it's very difficult to guarantee an exact
result (to some number of bits).  An occasional difference of 1 in the
last bit might not matter to a typical signal processing algorithm, but
is of course of vital importance to MPIR.


File: mpir.info,  Node: Unbalanced Multiplication,  Prev: Other Multiplication,  Up: Multiplication Algorithms

16.1.7 Unbalanced Multiplication
--------------------------------

Multiplication of operands with different sizes, both below
'MUL_KARATSUBA_THRESHOLD' are done with plain schoolbook multiplication
(*note Basecase Multiplication::).

   For really large operands, we invoke the FFT directly.

   For operands between these sizes, we use Toom inspired algorithms
suggested by Alberto Zanoni and Marco Bodrato.  The idea is to split the
operands into polynomials of different degree.  These algorithms are
denoted ToomMN where the first input is broken into M components and the
second operand is broken into N components.  MPIR currently implements
Toom32, Toom33, Toom44, Toom53 and Toom8h which deals with a variety of
sizes where the product polynomial will have length 15 or 16.


File: mpir.info,  Node: Division Algorithms,  Next: Greatest Common Divisor Algorithms,  Prev: Multiplication Algorithms,  Up: Algorithms

16.2 Division Algorithms
========================

* Menu:

* Single Limb Division::
* Basecase Division::
* Divide and Conquer Division::
* Exact Division::
* Exact Remainder::
* Small Quotient Division::


File: mpir.info,  Node: Single Limb Division,  Next: Basecase Division,  Prev: Division Algorithms,  Up: Division Algorithms

16.2.1 Single Limb Division
---------------------------

Nx1 division is implemented using repeated 2x1 divisions from high to
low, either with a hardware divide instruction or a multiplication by
inverse, whichever is best on a given CPU.

   The multiply by inverse follows section 8 of "Division by Invariant
Integers using Multiplication" by Granlund and Montgomery (*note
References::) and is implemented as 'udiv_qrnnd_preinv' in 'gmp-impl.h'.
The idea is to have a fixed-point approximation to 1/d (see
'invert_limb') and then multiply by the high limb (plus one bit) of the
dividend to get a quotient q.  With d normalized (high bit set), q is no
more than 1 too small.  Subtracting q*d from the dividend gives a
remainder, and reveals whether q or q-1 is correct.

   The result is a division done with two multiplications and four or
five arithmetic operations.  On CPUs with low latency multipliers this
can be much faster than a hardware divide, though the cost of
calculating the inverse at the start may mean it's only better on inputs
bigger than say 4 or 5 limbs.

   When a divisor must be normalized, either for the generic C
'__udiv_qrnnd_c' or the multiply by inverse, the division performed is
actually a*2^k by d*2^k where a is the dividend and k is the power
necessary to have the high bit of d*2^k set.  The bit shifts for the
dividend are usually accomplished "on the fly" meaning by extracting the
appropriate bits at each step.  Done this way the quotient limbs come
out aligned ready to store.  When only the remainder is wanted, an
alternative is to take the dividend limbs unshifted and calculate r = a
mod d*2^k followed by an extra final step r*2^k mod d*2^k.  This can
help on CPUs with poor bit shifts or few registers.

   The multiply by inverse can be done two limbs at a time.  The
calculation is basically the same, but the inverse is two limbs and the
divisor treated as if padded with a low zero limb.  This means more
work, since the inverse will need a 2x2 multiply, but the four 1x1s to
do that are independent and can therefore be done partly or wholly in
parallel.  Likewise for a 2x1 calculating q*d.  The net effect is to
process two limbs with roughly the same two multiplies worth of latency
that one limb at a time gives.  This extends to 3 or 4 limbs at a time,
though the extra work to apply the inverse will almost certainly soon
reach the limits of multiplier throughput.

   A similar approach in reverse can be taken to process just half a
limb at a time if the divisor is only a half limb.  In this case the 1x1
multiply for the inverse effectively becomes two (1/2)x1 for each limb,
which can be a saving on CPUs with a fast half limb multiply, or in fact
if the only multiply is a half limb, and especially if it's not
pipelined.


File: mpir.info,  Node: Basecase Division,  Next: Divide and Conquer Division,  Prev: Single Limb Division,  Up: Division Algorithms

16.2.2 Basecase Division
------------------------

This section is out-of-date.

   Basecase NxM division is like long division done by hand, but in base
2^mp_bits_per_limb.  See Knuth section 4.3.1 algorithm D.

   Briefly stated, while the dividend remains larger than the divisor, a
high quotient limb is formed and the Nx1 product q*d subtracted at the
top end of the dividend.  With a normalized divisor (most significant
bit set), each quotient limb can be formed with a 2x1 division and a 1x1
multiplication plus some subtractions.  The 2x1 division is by the high
limb of the divisor and is done either with a hardware divide or a
multiply by inverse (the same as in *note Single Limb Division::)
whichever is faster.  Such a quotient is sometimes one too big,
requiring an addback of the divisor, but that happens rarely.

   With Q=N-M being the number of quotient limbs, this is an O(Q*M)
algorithm and will run at a speed similar to a basecase QxM
multiplication, differing in fact only in the extra multiply and divide
for each of the Q quotient limbs.


File: mpir.info,  Node: Divide and Conquer Division,  Next: Exact Division,  Prev: Basecase Division,  Up: Division Algorithms

16.2.3 Divide and Conquer Division
----------------------------------

This section is out-of-date

   For divisors larger than 'DIV_DC_THRESHOLD', division is done by
dividing.  Or to be precise by a recursive divide and conquer algorithm
based on work by Moenck and Borodin, Jebelean, and Burnikel and Ziegler
(*note References::).

   The algorithm consists essentially of recognising that a 2NxN
division can be done with the basecase division algorithm (*note
Basecase Division::), but using N/2 limbs as a base, not just a single
limb.  This way the multiplications that arise are (N/2)x(N/2) and can
take advantage of Karatsuba and higher multiplication algorithms (*note
Multiplication Algorithms::).  The two "digits" of the quotient are
formed by recursive Nx(N/2) divisions.

   If the (N/2)x(N/2) multiplies are done with a basecase multiplication
then the work is about the same as a basecase division, but with more
function call overheads and with some subtractions separated from the
multiplies.  These overheads mean that it's only when N/2 is above
'MUL_KARATSUBA_THRESHOLD' that divide and conquer is of use.

   'DIV_DC_THRESHOLD' is based on the divisor size N, so it will be
somewhere above twice 'MUL_KARATSUBA_THRESHOLD', but how much above
depends on the CPU.  An optimized 'mpn_mul_basecase' can lower
'DIV_DC_THRESHOLD' a little by offering a ready-made advantage over
repeated 'mpn_submul_1' calls.

   Divide and conquer is asymptotically O(M(N)*log(N)) where M(N) is the
time for an NxN multiplication done with FFTs.  The actual time is a sum
over multiplications of the recursed sizes, as can be seen near the end
of section 2.2 of Burnikel and Ziegler.  For example, within the Toom-3
range, divide and conquer is 2.63*M(N).  With higher algorithms the M(N)
term improves and the multiplier tends to log(N).  In practice, at
moderate to large sizes, a 2NxN division is about 2 to 4 times slower
than an NxN multiplication.

   Newton's method used for division is asymptotically O(M(N)) and
should therefore be superior to divide and conquer, but it's believed
this would only be for large to very large N.


File: mpir.info,  Node: Exact Division,  Next: Exact Remainder,  Prev: Divide and Conquer Division,  Up: Division Algorithms

16.2.4 Exact Division
---------------------

This section is out-of-date

   A so-called exact division is when the dividend is known to be an
exact multiple of the divisor.  Jebelean's exact division algorithm uses
this knowledge to make some significant optimizations (*note
References::).

   The idea can be illustrated in decimal for example with 368154
divided by 543.  Because the low digit of the dividend is 4, the low
digit of the quotient must be 8.  This is arrived at from 4*7 mod 10,
using the fact 7 is the modular inverse of 3 (the low digit of the
divisor), since 3*7 == 1 mod 10.  So 8*543=4344 can be subtracted from
the dividend leaving 363810.  Notice the low digit has become zero.

   The procedure is repeated at the second digit, with the next quotient
digit 7 (7 == 1*7 mod 10), subtracting 7*543=3801, leaving 325800.  And
finally at the third digit with quotient digit 6 (8*7 mod 10),
subtracting 6*543=3258 leaving 0.  So the quotient is 678.

   Notice however that the multiplies and subtractions don't need to
extend past the low three digits of the dividend, since that's enough to
determine the three quotient digits.  For the last quotient digit no
subtraction is needed at all.  On a 2NxN division like this one, only
about half the work of a normal basecase division is necessary.

   For an NxM exact division producing Q=N-M quotient limbs, the saving
over a normal basecase division is in two parts.  Firstly, each of the Q
quotient limbs needs only one multiply, not a 2x1 divide and multiply.
Secondly, the crossproducts are reduced when Q>M to Q*M-M*(M+1)/2, or
when Q<=M to Q*(Q-1)/2.  Notice the savings are complementary.  If Q is
big then many divisions are saved, or if Q is small then the
crossproducts reduce to a small number.

   The modular inverse used is calculated efficiently by
'modlimb_invert' in 'gmp-impl.h'.  This does four multiplies for a
32-bit limb, or six for a 64-bit limb.  'tune/modlinv.c' has some
alternate implementations that might suit processors better at bit
twiddling than multiplying.

   The sub-quadratic exact division described by Jebelean in "Exact
Division with Karatsuba Complexity" is not currently implemented.  It
uses a rearrangement similar to the divide and conquer for normal
division (*note Divide and Conquer Division::), but operating from low
to high.  A further possibility not currently implemented is
"Bidirectional Exact Integer Division" by Krandick and Jebelean which
forms quotient limbs from both the high and low ends of the dividend,
and can halve once more the number of crossproducts needed in a 2NxN
division.

   A special case exact division by 3 exists in 'mpn_divexact_by3',
supporting Toom-3 multiplication and 'mpq' canonicalizations.  It forms
quotient digits with a multiply by the modular inverse of 3 (which is
'0xAA..AAB') and uses two comparisons to determine a borrow for the next
limb.  The multiplications don't need to be on the dependent chain, as
long as the effect of the borrows is applied, which can help chips with
pipelined multipliers.


File: mpir.info,  Node: Exact Remainder,  Next: Small Quotient Division,  Prev: Exact Division,  Up: Division Algorithms

16.2.5 Exact Remainder
----------------------

If the exact division algorithm is done with a full subtraction at each
stage and the dividend isn't a multiple of the divisor, then low zero
limbs are produced but with a remainder in the high limbs.  For dividend
a, divisor d, quotient q, and b = 2^mp_bits_per_limb, this remainder r
is of the form

     a = q*d + r*b^n

   n represents the number of zero limbs produced by the subtractions,
that being the number of limbs produced for q.  r will be in the range
0<=r<d and can be viewed as a remainder, but one shifted up by a factor
of b^n.

   Carrying out full subtractions at each stage means the same number of
cross products must be done as a normal division, but there's still some
single limb divisions saved.  When d is a single limb some
simplifications arise, providing good speedups on a number of
processors.

   'mpn_bdivmod', 'mpn_divexact_by3', 'mpn_modexact_1_odd' and the
'redc' function in 'mpz_powm' differ subtly in how they return r,
leading to some negations in the above formula, but all are essentially
the same.

   Clearly r is zero when a is a multiple of d, and this leads to
divisibility or congruence tests which are potentially more efficient
than a normal division.

   The factor of b^n on r can be ignored in a GCD when d is odd, hence
the use of 'mpn_bdivmod' in 'mpn_gcd', and the use of
'mpn_modexact_1_odd' by 'mpn_gcd_1' and 'mpz_kronecker_ui' etc (*note
Greatest Common Divisor Algorithms::).

   Montgomery's REDC method for modular multiplications uses operands of
the form of x*b^-n and y*b^-n and on calculating (x*b^-n)*(y*b^-n) uses
the factor of b^n in the exact remainder to reach a product in the same
form (x*y)*b^-n (*note Modular Powering Algorithm::).

   Notice that r generally gives no useful information about the
ordinary remainder a mod d since b^n mod d could be anything.  If
however b^n == 1 mod d, then r is the negative of the ordinary
remainder.  This occurs whenever d is a factor of b^n-1, as for example
with 3 in 'mpn_divexact_by3'.  For a 32 or 64 bit limb other such
factors include 5, 17 and 257, but no particular use has been found for
this.


File: mpir.info,  Node: Small Quotient Division,  Prev: Exact Remainder,  Up: Division Algorithms

16.2.6 Small Quotient Division
------------------------------

An NxM division where the number of quotient limbs Q=N-M is small can be
optimized somewhat.

   An ordinary basecase division normalizes the divisor by shifting it
to make the high bit set, shifting the dividend accordingly, and
shifting the remainder back down at the end of the calculation.  This is
wasteful if only a few quotient limbs are to be formed.  Instead a
division of just the top 2*Q limbs of the dividend by the top Q limbs of
the divisor can be used to form a trial quotient.  This requires only
those limbs normalized, not the whole of the divisor and dividend.

   A multiply and subtract then applies the trial quotient to the M-Q
unused limbs of the divisor and N-Q dividend limbs (which includes Q
limbs remaining from the trial quotient division).  The starting trial
quotient can be 1 or 2 too big, but all cases of 2 too big and most
cases of 1 too big are detected by first comparing the most significant
limbs that will arise from the subtraction.  An addback is done if the
quotient still turns out to be 1 too big.

   This whole procedure is essentially the same as one step of the
basecase algorithm done in a Q limb base, though with the trial quotient
test done only with the high limbs, not an entire Q limb "digit"
product.  The correctness of this weaker test can be established by
following the argument of Knuth section 4.3.1 exercise 20 but with the
v2*q>b*r+u2 condition appropriately relaxed.


File: mpir.info,  Node: Greatest Common Divisor Algorithms,  Next: Powering Algorithms,  Prev: Division Algorithms,  Up: Algorithms

16.3 Greatest Common Divisor
============================

* Menu:

* Binary GCD::
* Lehmer's GCD::
* Subquadratic GCD::
* Extended GCD::
* Jacobi Symbol::


File: mpir.info,  Node: Binary GCD,  Next: Lehmer's GCD,  Prev: Greatest Common Divisor Algorithms,  Up: Greatest Common Divisor Algorithms

16.3.1 Binary GCD
-----------------

At small sizes MPIR uses an O(N^2) binary style GCD.  This is described
in many textbooks, for example Knuth section 4.5.2 algorithm B.  It
simply consists of successively reducing odd operands a and b using

     a,b = abs(a-b),min(a,b)
     strip factors of 2 from a

   The Euclidean GCD algorithm, as per Knuth algorithms E and A, reduces
using a mod b but this has so far been found to be slower everywhere.
One reason the binary method does well is that the implied quotient at
each step is usually small, so often only one or two subtractions are
needed to get the same effect as a division.  Quotients 1, 2 and 3 for
example occur 67.7% of the time, see Knuth section 4.5.3 Theorem E.

   When the implied quotient is large, meaning b is much smaller than a,
then a division is worthwhile.  This is the basis for the initial a mod
b reductions in 'mpn_gcd' and 'mpn_gcd_1' (the latter for both Nx1 and
1x1 cases).  But after that initial reduction, big quotients occur too
rarely to make it worth checking for them.


   The final 1x1 GCD in 'mpn_gcd_1' is done in the generic C code as
described above.  For two N-bit operands, the algorithm takes about 0.68
iterations per bit.  For optimum performance some attention needs to be
paid to the way the factors of 2 are stripped from a.

   Firstly it may be noted that in twos complement the number of low
zero bits on a-b is the same as b-a, so counting or testing can begin on
a-b without waiting for abs(a-b) to be determined.

   A loop stripping low zero bits tends not to branch predict well,
since the condition is data dependent.  But on average there's only a
few low zeros, so an option is to strip one or two bits arithmetically
then loop for more (as done for AMD K6).  Or use a lookup table to get a
count for several bits then loop for more (as done for AMD K7).  An
alternative approach is to keep just one of a or b odd and iterate

     a,b = abs(a-b), min(a,b)
     a = a/2 if even
     b = b/2 if even

   This requires about 1.25 iterations per bit, but stripping of a
single bit at each step avoids any branching.  Repeating the bit strip
reduces to about 0.9 iterations per bit, which may be a worthwhile
tradeoff.

   Generally with the above approaches a speed of perhaps 6 cycles per
bit can be achieved, which is still not terribly fast with for instance
a 64-bit GCD taking nearly 400 cycles.  It's this sort of time which
means it's not usually advantageous to combine a set of divisibility
tests into a GCD.


File: mpir.info,  Node: Lehmer's GCD,  Next: Subquadratic GCD,  Prev: Binary GCD,  Up: Greatest Common Divisor Algorithms

16.3.2 Lehmer's GCD
-------------------

Lehmer's improvement of the Euclidean algorithms is based on the
observation that the initial part of the quotient sequence depends only
on the most significant parts of the inputs.  The variant of Lehmer's
algorithm used in MPIR splits off the most significant two limbs, as
suggested, e.g., in "A Double-Digit Lehmer-Euclid Algorithm" by Jebelean
(*note References::).  The quotients of two double-limb inputs are
collected as a 2 by 2 matrix with single-limb elements.  This is done by
the function 'mpn_hgcd2'.  The resulting matrix is applied to the inputs
using 'mpn_mul_1' and 'mpn_submul_1'.  Each iteration usually reduces
the inputs by almost one limb.  In the rare case of a large quotient, no
progress can be made by examining just the most significant two limbs,
and the quotient is computing using plain division.

   The resulting algorithm is asymptotically O(N^2), just as the
Euclidean algorithm and the binary algorithm.  The quadratic part of the
work are the calls to 'mpn_mul_1' and 'mpn_submul_1'.  For small sizes,
the linear work is also significant.  There are roughly N calls to the
'mpn_hgcd2' function.  This function uses a couple of important
optimizations:

   * It uses the same relaxed notion of correctness as 'mpn_hgcd' (see
     next section).  This means that when called with the most
     significant two limbs of two large numbers, the returned matrix
     does not always correspond exactly to the initial quotient sequence
     for the two large numbers; the final quotient may sometimes be one
     off.

   * It takes advantage of the fact the quotients are usually small.
     The division operator is not used, since the corresponding
     assembler instruction is very slow on most architectures.  (This
     code could probably be improved further, it uses many branches that
     are unfriendly to prediction).

   * It switches from double-limb calculations to single-limb
     calculations half-way through, when the input numbers have been
     reduced in size from two limbs to one and a half.


File: mpir.info,  Node: Subquadratic GCD,  Next: Extended GCD,  Prev: Lehmer's GCD,  Up: Greatest Common Divisor Algorithms

16.3.3 Subquadratic GCD
-----------------------

For inputs larger than 'GCD_DC_THRESHOLD', GCD is computed via the HGCD
(Half GCD) function, as a generalization to Lehmer's algorithm.

   Let the inputs a,b be of size N limbs each.  Put S = floor(N/2) + 1.
Then HGCD(a,b) returns a transformation matrix T with non-negative
elements, and reduced numbers (c;d) = T^{-1} (a;b).  The reduced numbers
c,d must be larger than S limbs, while their difference abs(c-d) must
fit in S limbs.  The matrix elements will also be of size roughly N/2.

   The HGCD base case uses Lehmer's algorithm, but with the above stop
condition that returns reduced numbers and the corresponding
transformation matrix half-way through.  For inputs larger than
'HGCD_THRESHOLD', HGCD is computed recursively, using the divide and
conquer algorithm in "On Scho"nhage's algorithm and subquadratic integer
GCD computation" by Mo"ller (*note References::).  The recursive
algorithm consists of these main steps.

   * Call HGCD recursively, on the most significant N/2 limbs.  Apply
     the resulting matrix T_1 to the full numbers, reducing them to a
     size just above 3N/2.

   * Perform a small number of division or subtraction steps to reduce
     the numbers to size below 3N/2.  This is essential mainly for the
     unlikely case of large quotients.

   * Call HGCD recursively, on the most significant N/2 limbs of the
     reduced numbers.  Apply the resulting matrix T_2 to the full
     numbers, reducing them to a size just above N/2.

   * Compute T = T_1 T_2.

   * Perform a small number of division and subtraction steps to satisfy
     the requirements, and return.

   GCD is then implemented as a loop around HGCD, similarly to Lehmer's
algorithm.  Where Lehmer repeatedly chops off the top two limbs, calls
'mpn_hgcd2', and applies the resulting matrix to the full numbers, the
subquadratic GCD chops off the most significant third of the limbs (the
proportion is a tuning parameter, and 1/3 seems to be more efficient
than, e.g, 1/2), calls 'mpn_hgcd', and applies the resulting matrix.
Once the input numbers are reduced to size below 'GCD_DC_THRESHOLD',
Lehmer's algorithm is used for the rest of the work.

   The asymptotic running time of both HGCD and GCD is O(M(N)*log(N)),
where M(N) is the time for multiplying two N-limb numbers.


File: mpir.info,  Node: Extended GCD,  Next: Jacobi Symbol,  Prev: Subquadratic GCD,  Up: Greatest Common Divisor Algorithms

16.3.4 Extended GCD
-------------------

The extended GCD function, or gcdext, calculates gcd(a,b) and also one
of the cofactors x and y satisfying a*x+b*y=gcd(a,b).  The algorithms
used for plain GCD are extended to handle this case.

   Lehmer's algorithm is used for sizes up to 'GCDEXT_DC_THRESHOLD'.
Above this threshold, GCDEXT is implemented as a loop around HGCD, but
with more book-keeping to keep track of the cofactors.


File: mpir.info,  Node: Jacobi Symbol,  Prev: Extended GCD,  Up: Greatest Common Divisor Algorithms

16.3.5 Jacobi Symbol
--------------------

'mpz_jacobi' and 'mpz_kronecker' are currently implemented with a simple
binary algorithm similar to that described for the GCDs (*note Binary
GCD::).  They're not very fast when both inputs are large.  Lehmer's
multi-step improvement or a binary based multi-step algorithm is likely
to be better.

   When one operand fits a single limb, and that includes
'mpz_kronecker_ui' and friends, an initial reduction is done with either
'mpn_mod_1' or 'mpn_modexact_1_odd', followed by the binary algorithm on
a single limb.  The binary algorithm is well suited to a single limb,
and the whole calculation in this case is quite efficient.

   In all the routines sign changes for the result are accumulated using
some bit twiddling, avoiding table lookups or conditional jumps.


File: mpir.info,  Node: Powering Algorithms,  Next: Root Extraction Algorithms,  Prev: Greatest Common Divisor Algorithms,  Up: Algorithms

16.4 Powering Algorithms
========================

* Menu:

* Normal Powering Algorithm::
* Modular Powering Algorithm::


File: mpir.info,  Node: Normal Powering Algorithm,  Next: Modular Powering Algorithm,  Prev: Powering Algorithms,  Up: Powering Algorithms

16.4.1 Normal Powering
----------------------

Normal 'mpz' or 'mpf' powering uses a simple binary algorithm,
successively squaring and then multiplying by the base when a 1 bit is
seen in the exponent, as per Knuth section 4.6.3.  The "left to right"
variant described there is used rather than algorithm A, since it's just
as easy and can be done with somewhat less temporary memory.


File: mpir.info,  Node: Modular Powering Algorithm,  Prev: Normal Powering Algorithm,  Up: Powering Algorithms

16.4.2 Modular Powering
-----------------------

Modular powering is implemented using a 2^k-ary sliding window
algorithm, as per "Handbook of Applied Cryptography" algorithm 14.85
(*note References::).  k is chosen according to the size of the
exponent.  Larger exponents use larger values of k, the choice being
made to minimize the average number of multiplications that must
supplement the squaring.

   The modular multiplies and squares use either a simple division or
the REDC method by Montgomery (*note References::).  REDC is a little
faster, essentially saving N single limb divisions in a fashion similar
to an exact remainder (*note Exact Remainder::).  The current REDC has
some limitations.  It's only O(N^2) so above 'POWM_THRESHOLD' division
becomes faster and is used.  It doesn't attempt to detect small bases,
but rather always uses a REDC form, which is usually a full size
operand.  And lastly it's only applied to odd moduli.


File: mpir.info,  Node: Root Extraction Algorithms,  Next: Radix Conversion Algorithms,  Prev: Powering Algorithms,  Up: Algorithms

16.5 Root Extraction Algorithms
===============================

* Menu:

* Square Root Algorithm::
* Nth Root Algorithm::
* Perfect Square Algorithm::
* Perfect Power Algorithm::


File: mpir.info,  Node: Square Root Algorithm,  Next: Nth Root Algorithm,  Prev: Root Extraction Algorithms,  Up: Root Extraction Algorithms

16.5.1 Square Root
------------------

Square roots are taken using the "Karatsuba Square Root" algorithm by
Paul Zimmermann (*note References::).

   An input n is split into four parts of k bits each, so with b=2^k we
have n = a3*b^3 + a2*b^2 + a1*b + a0.  Part a3 must be "normalized" so
that either the high or second highest bit is set.  In MPIR, k is kept
on a limb boundary and the input is left shifted (by an even number of
bits) to normalize.

   The square root of the high two parts is taken, by recursive
application of the algorithm (bottoming out in a one-limb Newton's
method),

     s1,r1 = sqrtrem (a3*b + a2)

   This is an approximation to the desired root and is extended by a
division to give s,r,

     q,u = divrem (r1*b + a1, 2*s1)
     s = s1*b + q
     r = u*b + a0 - q^2

   The normalization requirement on a3 means at this point s is either
correct or 1 too big.  r is negative in the latter case, so

     if r < 0 then
       r = r + 2*s - 1
       s = s - 1

   The algorithm is expressed in a divide and conquer form, but as noted
in the paper it can also be viewed as a discrete variant of Newton's
method, or as a variation on the schoolboy method (no longer taught) for
square roots two digits at a time.

   If the remainder r is not required then usually only a few high limbs
of r and u need to be calculated to determine whether an adjustment to s
is required.  This optimization is not currently implemented.

   In the Karatsuba multiplication range this algorithm is
O(1.5*M(N/2)), where M(n) is the time to multiply two numbers of n
limbs.  In the FFT multiplication range this grows to a bound of
O(6*M(N/2)).  In practice a factor of about 1.5 to 1.8 is found in the
Karatsuba and Toom-3 ranges, growing to 2 or 3 in the FFT range.

   The algorithm does all its calculations in integers and the resulting
'mpn_sqrtrem' is used for both 'mpz_sqrt' and 'mpf_sqrt'.  The extended
precision given by 'mpf_sqrt_ui' is obtained by padding with zero limbs.


File: mpir.info,  Node: Nth Root Algorithm,  Next: Perfect Square Algorithm,  Prev: Square Root Algorithm,  Up: Root Extraction Algorithms

16.5.2 Nth Root
---------------

Integer Nth roots are taken using Newton's method with the following
iteration, where A is the input and n is the root to be taken.

              1         A
     a[i+1] = - * ( --------- + (n-1)*a[i] )
              n     a[i]^(n-1)

   The initial approximation a[1] is generated bitwise by successively
powering a trial root with or without new 1 bits, aiming to be just
above the true root.  The iteration converges quadratically when started
from a good approximation.  When n is large more initial bits are needed
to get good convergence.  The current implementation is not particularly
well optimized.


File: mpir.info,  Node: Perfect Square Algorithm,  Next: Perfect Power Algorithm,  Prev: Nth Root Algorithm,  Up: Root Extraction Algorithms

16.5.3 Perfect Square
---------------------

A significant fraction of non-squares can be quickly identified by
checking whether the input is a quadratic residue modulo small integers.

   'mpz_perfect_square_p' first tests the input mod 256, which means
just examining the low byte.  Only 44 different values occur for squares
mod 256, so 82.8% of inputs can be immediately identified as
non-squares.

   On a 32-bit system similar tests are done mod 9, 5, 7, 13 and 17, for
a total 99.25% of inputs identified as non-squares.  On a 64-bit system
97 is tested too, for a total 99.62%.

   These moduli are chosen because they're factors of 2^24-1 (or 2^48-1
for 64-bits), and such a remainder can be quickly taken just using
additions (see 'mpn_mod_34lsub1').

   When nails are in use moduli are instead selected by the 'gen-psqr.c'
program and applied with an 'mpn_mod_1'.  The same 2^24-1 or 2^48-1
could be done with nails using some extra bit shifts, but this is not
currently implemented.

   In any case each modulus is applied to the 'mpn_mod_34lsub1' or
'mpn_mod_1' remainder and a table lookup identifies non-squares.  By
using a "modexact" style calculation, and suitably permuted tables, just
one multiply each is required, see the code for details.  Moduli are
also combined to save operations, so long as the lookup tables don't
become too big.  'gen-psqr.c' does all the pre-calculations.

   A square root must still be taken for any value that passes these
tests, to verify it's really a square and not one of the small fraction
of non-squares that get through (ie. a pseudo-square to all the tested
bases).

   Clearly more residue tests could be done, 'mpz_perfect_square_p' only
uses a compact and efficient set.  Big inputs would probably benefit
from more residue testing, small inputs might be better off with less.
The assumed distribution of squares versus non-squares in the input
would affect such considerations.


File: mpir.info,  Node: Perfect Power Algorithm,  Prev: Perfect Square Algorithm,  Up: Root Extraction Algorithms

16.5.4 Perfect Power
--------------------

Detecting perfect powers is required by some factorization algorithms.
Currently 'mpz_perfect_power_p' is implemented using repeated Nth root
extractions, though naturally only prime roots need to be considered.
(*Note Nth Root Algorithm::.)

   If a prime divisor p with multiplicity e can be found, then only
roots which are divisors of e need to be considered, much reducing the
work necessary.  To this end divisibility by a set of small primes is
checked.


File: mpir.info,  Node: Radix Conversion Algorithms,  Next: Other Algorithms,  Prev: Root Extraction Algorithms,  Up: Algorithms

16.6 Radix Conversion
=====================

Radix conversions are less important than other algorithms.  A program
dominated by conversions should probably use a different data
representation.

* Menu:

* Binary to Radix::
* Radix to Binary::


File: mpir.info,  Node: Binary to Radix,  Next: Radix to Binary,  Prev: Radix Conversion Algorithms,  Up: Radix Conversion Algorithms

16.6.1 Binary to Radix
----------------------

Conversions from binary to a power-of-2 radix use a simple and fast O(N)
bit extraction algorithm.

   Conversions from binary to other radices use one of two algorithms.
Sizes below 'GET_STR_PRECOMPUTE_THRESHOLD' use a basic O(N^2) method.
Repeated divisions by b^n are made, where b is the radix and n is the
biggest power that fits in a limb.  But instead of simply using the
remainder r from such divisions, an extra divide step is done to give a
fractional limb representing r/b^n.  The digits of r can then be
extracted using multiplications by b rather than divisions.  Special
case code is provided for decimal, allowing multiplications by 10 to
optimize to shifts and adds.

   Above 'GET_STR_PRECOMPUTE_THRESHOLD' a sub-quadratic algorithm is
used.  For an input t, powers b^(n*2^i) of the radix are calculated,
until a power between t and sqrt(t) is reached.  t is then divided by
that largest power, giving a quotient which is the digits above that
power, and a remainder which is those below.  These two parts are in
turn divided by the second highest power, and so on recursively.  When a
piece has been divided down to less than 'GET_STR_DC_THRESHOLD' limbs,
the basecase algorithm described above is used.

   The advantage of this algorithm is that big divisions can make use of
the sub-quadratic divide and conquer division (*note Divide and Conquer
Division::), and big divisions tend to have less overheads than lots of
separate single limb divisions anyway.  But in any case the cost of
calculating the powers b^(n*2^i) must first be overcome.

   'GET_STR_PRECOMPUTE_THRESHOLD' and 'GET_STR_DC_THRESHOLD' represent
the same basic thing, the point where it becomes worth doing a big
division to cut the input in half.  'GET_STR_PRECOMPUTE_THRESHOLD'
includes the cost of calculating the radix power required, whereas
'GET_STR_DC_THRESHOLD' assumes that's already available, which is the
case when recursing.

   Since the base case produces digits from least to most significant
but they want to be stored from most to least, it's necessary to
calculate in advance how many digits there will be, or at least be sure
not to underestimate that.  For MPIR the number of input bits is
multiplied by 'chars_per_bit_exactly' from 'mp_bases', rounding up.  The
result is either correct or one too big.

   Examining some of the high bits of the input could increase the
chance of getting the exact number of digits, but an exact result every
time would not be practical, since in general the difference between
numbers 100... and 99... is only in the last few bits and the work to
identify 99... might well be almost as much as a full conversion.

   'mpf_get_str' doesn't currently use the algorithm described here, it
multiplies or divides by a power of b to move the radix point to the
just above the highest non-zero digit (or at worst one above that
location), then multiplies by b^n to bring out digits.  This is O(N^2)
and is certainly not optimal.

   The r/b^n scheme described above for using multiplications to bring
out digits might be useful for more than a single limb.  Some brief
experiments with it on the base case when recursing didn't give a
noticeable improvement, but perhaps that was only due to the
implementation.  Something similar would work for the sub-quadratic
divisions too, though there would be the cost of calculating a bigger
radix power.

   Another possible improvement for the sub-quadratic part would be to
arrange for radix powers that balanced the sizes of quotient and
remainder produced, ie. the highest power would be an b^(n*k)
approximately equal to sqrt(t), not restricted to a 2^i factor.  That
ought to smooth out a graph of times against sizes, but may or may not
be a net speedup.


File: mpir.info,  Node: Radix to Binary,  Prev: Binary to Radix,  Up: Radix Conversion Algorithms

16.6.2 Radix to Binary
----------------------

This section is out-of-date.

   Conversions from a power-of-2 radix into binary use a simple and fast
O(N) bitwise concatenation algorithm.

   Conversions from other radices use one of two algorithms.  Sizes
below 'SET_STR_THRESHOLD' use a basic O(N^2) method.  Groups of n digits
are converted to limbs, where n is the biggest power of the base b which
will fit in a limb, then those groups are accumulated into the result by
multiplying by b^n and adding.  This saves multi-precision operations,
as per Knuth section 4.4 part E (*note References::).  Some special case
code is provided for decimal, giving the compiler a chance to optimize
multiplications by 10.

   Above 'SET_STR_THRESHOLD' a sub-quadratic algorithm is used.  First
groups of n digits are converted into limbs.  Then adjacent limbs are
combined into limb pairs with x*b^n+y, where x and y are the limbs.
Adjacent limb pairs are combined into quads similarly with x*b^(2n)+y.
This continues until a single block remains, that being the result.

   The advantage of this method is that the multiplications for each x
are big blocks, allowing Karatsuba and higher algorithms to be used.
But the cost of calculating the powers b^(n*2^i) must be overcome.
'SET_STR_THRESHOLD' usually ends up quite big, around 5000 digits, and
on some processors much bigger still.

   'SET_STR_THRESHOLD' is based on the input digits (and tuned for
decimal), though it might be better based on a limb count, so as to be
independent of the base.  But that sort of count isn't used by the base
case and so would need some sort of initial calculation or estimate.

   The main reason 'SET_STR_THRESHOLD' is so much bigger than the
corresponding 'GET_STR_PRECOMPUTE_THRESHOLD' is that 'mpn_mul_1' is much
faster than 'mpn_divrem_1' (often by a factor of 10, or more).


File: mpir.info,  Node: Other Algorithms,  Next: Assembler Coding,  Prev: Radix Conversion Algorithms,  Up: Algorithms

16.7 Other Algorithms
=====================

* Menu:

* Prime Testing Algorithm::
* Factorial Algorithm::
* Binomial Coefficients Algorithm::
* Fibonacci Numbers Algorithm::
* Lucas Numbers Algorithm::
* Random Number Algorithms::


File: mpir.info,  Node: Prime Testing Algorithm,  Next: Factorial Algorithm,  Prev: Other Algorithms,  Up: Other Algorithms

16.7.1 Prime Testing
--------------------

This section is somewhat out-of-date.

   The primality testing in 'mpz_probab_prime_p' (*note Number Theoretic
Functions::) first does some trial division by small factors and then
uses the Miller-Rabin probabilistic primality testing algorithm, as
described in Knuth section 4.5.4 algorithm P (*note References::).

   For an odd input n, and with n = q*2^k+1 where q is odd, this
algorithm selects a random base x and tests whether x^q mod n is 1 or
-1, or an x^(q*2^j) mod n is 1, for 1<=j<=k.  If so then n is probably
prime, if not then n is definitely composite.

   Any prime n will pass the test, but some composites do too.  Such
composites are known as strong pseudoprimes to base x.  No n is a strong
pseudoprime to more than 1/4 of all bases (see Knuth exercise 22), hence
with x chosen at random there's no more than a 1/4 chance a "probable
prime" will in fact be composite.

   In fact strong pseudoprimes are quite rare, making the test much more
powerful than this analysis would suggest, but 1/4 is all that's proven
for an arbitrary n.


File: mpir.info,  Node: Factorial Algorithm,  Next: Binomial Coefficients Algorithm,  Prev: Prime Testing Algorithm,  Up: Other Algorithms

16.7.2 Factorial
----------------

This section is out-of-date.

   Factorials are calculated by a combination of removal of twos,
powering, and binary splitting.  The procedure can be best illustrated
with an example,

     23! = 1.2.3.4.5.6.7.8.9.10.11.12.13.14.15.16.17.18.19.20.21.22.23

has factors of two removed,

     23! = 2^{19}.1.1.3.1.5.3.7.1.9.5.11.3.13.7.15.1.17.9.19.5.21.11.23

and the resulting terms collected up according to their multiplicity,

     23! = 2^{19}.(3.5)^3.(7.9.11)^2.(13.15.17.19.21.23)

   Each sequence such as 13.15.17.19.21.23 is evaluated by splitting
into every second term, as for instance (13.17.21).(15.19.23), and the
same recursively on each half.  This is implemented iteratively using
some bit twiddling.

   Such splitting is more efficient than repeated Nx1 multiplies since
it forms big multiplies, allowing Karatsuba and higher algorithms to be
used.  And even below the Karatsuba threshold a big block of work can be
more efficient for the basecase algorithm.

   Splitting into subsequences of every second term keeps the resulting
products more nearly equal in size than would the simpler approach of
say taking the first half and second half of the sequence.  Nearly equal
products are more efficient for the current multiply implementation.


File: mpir.info,  Node: Binomial Coefficients Algorithm,  Next: Fibonacci Numbers Algorithm,  Prev: Factorial Algorithm,  Up: Other Algorithms

16.7.3 Binomial Coefficients
----------------------------

Binomial coefficients C(n,k) are calculated by first arranging k <= n/2
using C(n,k) = C(n,n-k) if necessary, and then evaluating the following
product simply from i=2 to i=k.

                           k  (n-k+i)
     C(n,k) =  (n-k+1) * prod -------
                          i=2    i

   It's easy to show that each denominator i will divide the product so
far, so the exact division algorithm is used (*note Exact Division::).

   The numerators n-k+i and denominators i are first accumulated into as
many fit a limb, to save multi-precision operations, though for
'mpz_bin_ui' this applies only to the divisors, since n is an 'mpz_t'
and n-k+i in general won't fit in a limb at all.


File: mpir.info,  Node: Fibonacci Numbers Algorithm,  Next: Lucas Numbers Algorithm,  Prev: Binomial Coefficients Algorithm,  Up: Other Algorithms

16.7.4 Fibonacci Numbers
------------------------

The Fibonacci functions 'mpz_fib_ui' and 'mpz_fib2_ui' are designed for
calculating isolated F[n] or F[n],F[n-1] values efficiently.

   For small n, a table of single limb values in '__gmp_fib_table' is
used.  On a 32-bit limb this goes up to F[47], or on a 64-bit limb up to
F[93].  For convenience the table starts at F[-1].

   Beyond the table, values are generated with a binary powering
algorithm, calculating a pair F[n] and F[n-1] working from high to low
across the bits of n.  The formulas used are

     F[2k+1] = 4*F[k]^2 - F[k-1]^2 + 2*(-1)^k
     F[2k-1] =   F[k]^2 + F[k-1]^2

     F[2k] = F[2k+1] - F[2k-1]

   At each step, k is the high b bits of n.  If the next bit of n is 0
then F[2k],F[2k-1] is used, or if it's a 1 then F[2k+1],F[2k] is used,
and the process repeated until all bits of n are incorporated.  Notice
these formulas require just two squares per bit of n.

   It'd be possible to handle the first few n above the single limb
table with simple additions, using the defining Fibonacci recurrence
F[k+1]=F[k]+F[k-1], but this is not done since it usually turns out to
be faster for only about 10 or 20 values of n, and including a block of
code for just those doesn't seem worthwhile.  If they really mattered
it'd be better to extend the data table.

   Using a table avoids lots of calculations on small numbers, and makes
small n go fast.  A bigger table would make more small n go fast, it's
just a question of balancing size against desired speed.  For MPIR the
code is kept compact, with the emphasis primarily on a good powering
algorithm.

   'mpz_fib2_ui' returns both F[n] and F[n-1], but 'mpz_fib_ui' is only
interested in F[n].  In this case the last step of the algorithm can
become one multiply instead of two squares.  One of the following two
formulas is used, according as n is odd or even.

     F[2k]   = F[k]*(F[k]+2F[k-1])

     F[2k+1] = (2F[k]+F[k-1])*(2F[k]-F[k-1]) + 2*(-1)^k

   F[2k+1] here is the same as above, just rearranged to be a multiply.
For interest, the 2*(-1)^k term both here and above can be applied just
to the low limb of the calculation, without a carry or borrow into
further limbs, which saves some code size.  See comments with
'mpz_fib_ui' and the internal 'mpn_fib2_ui' for how this is done.


File: mpir.info,  Node: Lucas Numbers Algorithm,  Next: Random Number Algorithms,  Prev: Fibonacci Numbers Algorithm,  Up: Other Algorithms

16.7.5 Lucas Numbers
--------------------

'mpz_lucnum2_ui' derives a pair of Lucas numbers from a pair of
Fibonacci numbers with the following simple formulas.

     L[k]   =   F[k] + 2*F[k-1]
     L[k-1] = 2*F[k] -   F[k-1]

   'mpz_lucnum_ui' is only interested in L[n], and some work can be
saved.  Trailing zero bits on n can be handled with a single square
each.

     L[2k] = L[k]^2 - 2*(-1)^k

   And the lowest 1 bit can be handled with one multiply of a pair of
Fibonacci numbers, similar to what 'mpz_fib_ui' does.

     L[2k+1] = 5*F[k-1]*(2*F[k]+F[k-1]) - 4*(-1)^k


File: mpir.info,  Node: Random Number Algorithms,  Prev: Lucas Numbers Algorithm,  Up: Other Algorithms

16.7.6 Random Numbers
---------------------

For the 'urandomb' functions, random numbers are generated simply by
concatenating bits produced by the generator.  As long as the generator
has good randomness properties this will produce well-distributed N bit
numbers.

   For the 'urandomm' functions, random numbers in a range 0<=R<N are
generated by taking values R of ceil(log2(N)) bits each until one
satisfies R<N.  This will normally require only one or two attempts, but
the attempts are limited in case the generator is somehow degenerate and
produces only 1 bits or similar.

   The Mersenne Twister generator is by Matsumoto and Nishimura (*note
References::).  It has a non-repeating period of 2^19937-1, which is a
Mersenne prime, hence the name of the generator.  The state is 624 words
of 32-bits each, which is iterated with one XOR and shift for each
32-bit word generated, making the algorithm very fast.  Randomness
properties are also very good and this is the default algorithm used by
MPIR.

   Linear congruential generators are described in many text books, for
instance Knuth volume 2 (*note References::).  With a modulus M and
parameters A and C, a integer state S is iterated by the formula S <-
A*S+C mod M.  At each step the new state is a linear function of the
previous, mod M, hence the name of the generator.

   In MPIR only moduli of the form 2^N are supported, and the current
implementation is not as well optimized as it could be.  Overheads are
significant when N is small, and when N is large clearly the multiply at
each step will become slow.  This is not a big concern, since the
Mersenne Twister generator is better in every respect and is therefore
recommended for all normal applications.

   For both generators the current state can be deduced by observing
enough output and applying some linear algebra (over GF(2) in the case
of the Mersenne Twister).  This generally means raw output is unsuitable
for cryptographic applications without further hashing or the like.


File: mpir.info,  Node: Assembler Coding,  Prev: Other Algorithms,  Up: Algorithms

16.8 Assembler Coding
=====================

The assembler subroutines in MPIR are the most significant source of
speed at small to moderate sizes.  At larger sizes algorithm selection
becomes more important, but of course speedups in low level routines
will still speed up everything proportionally.

   Carry handling and widening multiplies that are important for MPIR
can't be easily expressed in C.  GCC 'asm' blocks help a lot and are
provided in 'longlong.h', but hand coding low level routines invariably
offers a speedup over generic C by a factor of anything from 2 to 10.

* Menu:

* Assembler Code Organisation::
* Assembler Basics::
* Assembler Carry Propagation::
* Assembler Cache Handling::
* Assembler Functional Units::
* Assembler Floating Point::
* Assembler SIMD Instructions::
* Assembler Software Pipelining::
* Assembler Loop Unrolling::
* Assembler Writing Guide::


File: mpir.info,  Node: Assembler Code Organisation,  Next: Assembler Basics,  Prev: Assembler Coding,  Up: Assembler Coding

16.8.1 Code Organisation
------------------------

The various 'mpn' subdirectories contain machine-dependent code, written
in C or assembler.  The 'mpn/generic' subdirectory contains default
code, used when there's no machine-specific version of a particular
file.

   Each 'mpn' subdirectory is for an ISA family.  Generally 32-bit and
64-bit variants in a family cannot share code and have separate
directories.  Within a family further subdirectories may exist for CPU
variants.

   In each directory a 'nails' subdirectory may exist, holding code with
nails support for that CPU variant.  A 'NAILS_SUPPORT' directive in each
file indicates the nails values the code handles.  Nails code only
exists where it's faster, or promises to be faster, than plain code.
There's no effort put into nails if they're not going to enhance a given
CPU.


File: mpir.info,  Node: Assembler Basics,  Next: Assembler Carry Propagation,  Prev: Assembler Code Organisation,  Up: Assembler Coding

16.8.2 Assembler Basics
-----------------------

'mpn_addmul_1' and 'mpn_submul_1' are the most important routines for
overall MPIR performance.  All multiplications and divisions come down
to repeated calls to these.  'mpn_add_n', 'mpn_sub_n', 'mpn_lshift' and
'mpn_rshift' are next most important.

   On some CPUs assembler versions of the internal functions
'mpn_mul_basecase' and 'mpn_sqr_basecase' give significant speedups,
mainly through avoiding function call overheads.  They can also
potentially make better use of a wide superscalar processor, as can
bigger primitives like 'mpn_addmul_2' or 'mpn_addmul_4'.

   The restrictions on overlaps between sources and destinations (*note
Low-level Functions::) are designed to facilitate a variety of
implementations.  For example, knowing 'mpn_add_n' won't have partly
overlapping sources and destination means reading can be done far ahead
of writing on superscalar processors, and loops can be vectorized on a
vector processor, depending on the carry handling.


File: mpir.info,  Node: Assembler Carry Propagation,  Next: Assembler Cache Handling,  Prev: Assembler Basics,  Up: Assembler Coding

16.8.3 Carry Propagation
------------------------

The problem that presents most challenges in MPIR is propagating carries
from one limb to the next.  In functions like 'mpn_addmul_1' and
'mpn_add_n', carries are the only dependencies between limb operations.

   On processors with carry flags, a straightforward CISC style 'adc' is
generally best.  AMD K6 'mpn_addmul_1' however is an example of an
unusual set of circumstances where a branch works out better.

   On RISC processors generally an add and compare for overflow is used.
This sort of thing can be seen in 'mpn/generic/aors_n.c'.  Some carry
propagation schemes require 4 instructions, meaning at least 4 cycles
per limb, but other schemes may use just 1 or 2.  On wide superscalar
processors performance may be completely determined by the number of
dependent instructions between carry-in and carry-out for each limb.

   On vector processors good use can be made of the fact that a carry
bit only very rarely propagates more than one limb.  When adding a
single bit to a limb, there's only a carry out if that limb was
'0xFF...FF' which on random data will be only 1 in 2^mp_bits_per_limb.
'mpn/cray/add_n.c' is an example of this, it adds all limbs in parallel,
adds one set of carry bits in parallel and then only rarely needs to
fall through to a loop propagating further carries.

   On the x86s, GCC (as of version 2.95.2) doesn't generate particularly
good code for the RISC style idioms that are necessary to handle carry
bits in C.  Often conditional jumps are generated where 'adc' or 'sbb'
forms would be better.  And so unfortunately almost any loop involving
carry bits needs to be coded in assembler for best results.


File: mpir.info,  Node: Assembler Cache Handling,  Next: Assembler Functional Units,  Prev: Assembler Carry Propagation,  Up: Assembler Coding

16.8.4 Cache Handling
---------------------

MPIR aims to perform well both on operands that fit entirely in L1 cache
and those which don't.

   Basic routines like 'mpn_add_n' or 'mpn_lshift' are often used on
large operands, so L2 and main memory performance is important for them.
'mpn_mul_1' and 'mpn_addmul_1' are mostly used for multiply and square
basecases, so L1 performance matters most for them, unless assembler
versions of 'mpn_mul_basecase' and 'mpn_sqr_basecase' exist, in which
case the remaining uses are mostly for larger operands.

   For L2 or main memory operands, memory access times will almost
certainly be more than the calculation time.  The aim therefore is to
maximize memory throughput, by starting a load of the next cache line
while processing the contents of the previous one.  Clearly this is only
possible if the chip has a lock-up free cache or some sort of prefetch
instruction.  Most current chips have both these features.

   Prefetching sources combines well with loop unrolling, since a
prefetch can be initiated once per unrolled loop (or more than once if
the loop covers more than one cache line).

   On CPUs without write-allocate caches, prefetching destinations will
ensure individual stores don't go further down the cache hierarchy,
limiting bandwidth.  Of course for calculations which are slow anyway,
like 'mpn_divrem_1', write-throughs might be fine.

   The distance ahead to prefetch will be determined by memory latency
versus throughput.  The aim of course is to have data arriving
continuously, at peak throughput.  Some CPUs have limits on the number
of fetches or prefetches in progress.

   If a special prefetch instruction doesn't exist then a plain load can
be used, but in that case care must be taken not to attempt to read past
the end of an operand, since that might produce a segmentation
violation.

   Some CPUs or systems have hardware that detects sequential memory
accesses and initiates suitable cache movements automatically, making
life easy.


File: mpir.info,  Node: Assembler Functional Units,  Next: Assembler Floating Point,  Prev: Assembler Cache Handling,  Up: Assembler Coding

16.8.5 Functional Units
-----------------------

When choosing an approach for an assembler loop, consideration is given
to what operations can execute simultaneously and what throughput can
thereby be achieved.  In some cases an algorithm can be tweaked to
accommodate available resources.

   Loop control will generally require a counter and pointer updates,
costing as much as 5 instructions, plus any delays a branch introduces.
CPU addressing modes might reduce pointer updates, perhaps by allowing
just one updating pointer and others expressed as offsets from it, or on
CISC chips with all addressing done with the loop counter as a scaled
index.

   The final loop control cost can be amortised by processing several
limbs in each iteration (*note Assembler Loop Unrolling::).  This at
least ensures loop control isn't a big fraction the work done.

   Memory throughput is always a limit.  If perhaps only one load or one
store can be done per cycle then 3 cycles/limb will the top speed for
"binary" operations like 'mpn_add_n', and any code achieving that is
optimal.

   Integer resources can be freed up by having the loop counter in a
float register, or by pressing the float units into use for some
multiplying, perhaps doing every second limb on the float side (*note
Assembler Floating Point::).

   Float resources can be freed up by doing carry propagation on the
integer side, or even by doing integer to float conversions in integers
using bit twiddling.


File: mpir.info,  Node: Assembler Floating Point,  Next: Assembler SIMD Instructions,  Prev: Assembler Functional Units,  Up: Assembler Coding

16.8.6 Floating Point
---------------------

Floating point arithmetic is used in MPIR for multiplications on CPUs
with poor integer multipliers.  It's mostly useful for 'mpn_mul_1',
'mpn_addmul_1' and 'mpn_submul_1' on 64-bit machines, and
'mpn_mul_basecase' on both 32-bit and 64-bit machines.

   With IEEE 53-bit double precision floats, integer multiplications
producing up to 53 bits will give exact results.  Breaking a 64x64
multiplication into eight 16x32->48 bit pieces is convenient.  With some
care though six 21x32->53 bit products can be used, if one of the lower
two 21-bit pieces also uses the sign bit.

   For the 'mpn_mul_1' family of functions on a 64-bit machine, the
invariant single limb is split at the start, into 3 or 4 pieces.  Inside
the loop, the bignum operand is split into 32-bit pieces.  Fast
conversion of these unsigned 32-bit pieces to floating point is highly
machine-dependent.  In some cases, reading the data into the integer
unit, zero-extending to 64-bits, then transferring to the floating point
unit back via memory is the only option.

   Converting partial products back to 64-bit limbs is usually best done
as a signed conversion.  Since all values are smaller than 2^53, signed
and unsigned are the same, but most processors lack unsigned
conversions.



   Here is a diagram showing 16x32 bit products for an 'mpn_mul_1' or
'mpn_addmul_1' with a 64-bit limb.  The single limb operand V is split
into four 16-bit parts.  The multi-limb operand U is split in the loop
into two 32-bit parts.

                     +---+---+---+---+
                     |v48|v32|v16|v00|    V operand
                     +---+---+---+---+

                     +-------+---+---+
                 x   |  u32  |  u00  |    U operand (one limb)
                     +---------------+

     ---------------------------------

                         +-----------+
                         | u00 x v00 |    p00    48-bit products
                         +-----------+
                     +-----------+
                     | u00 x v16 |        p16
                     +-----------+
                 +-----------+
                 | u00 x v32 |            p32
                 +-----------+
             +-----------+
             | u00 x v48 |                p48
             +-----------+
                 +-----------+
                 | u32 x v00 |            r32
                 +-----------+
             +-----------+
             | u32 x v16 |                r48
             +-----------+
         +-----------+
         | u32 x v32 |                    r64
         +-----------+
     +-----------+
     | u32 x v48 |                        r80
     +-----------+

   p32 and r32 can be summed using floating-point addition, and likewise
p48 and r48.  p00 and p16 can be summed with r64 and r80 from the
previous iteration.

   For each loop then, four 49-bit quantities are transfered to the
integer unit, aligned as follows,

     |-----64bits----|-----64bits----|
                        +------------+
                        | p00 + r64' |    i00
                        +------------+
                    +------------+
                    | p16 + r80' |        i16
                    +------------+
                +------------+
                | p32 + r32  |            i32
                +------------+
            +------------+
            | p48 + r48  |                i48
            +------------+

   The challenge then is to sum these efficiently and add in a carry
limb, generating a low 64-bit result limb and a high 33-bit carry limb
(i48 extends 33 bits into the high half).


File: mpir.info,  Node: Assembler SIMD Instructions,  Next: Assembler Software Pipelining,  Prev: Assembler Floating Point,  Up: Assembler Coding

16.8.7 SIMD Instructions
------------------------

The single-instruction multiple-data support in current microprocessors
is aimed at signal processing algorithms where each data point can be
treated more or less independently.  There's generally not much support
for propagating the sort of carries that arise in MPIR.

   SIMD multiplications of say four 16x16 bit multiplies only do as much
work as one 32x32 from MPIR's point of view, and need some shifts and
adds besides.  But of course if say the SIMD form is fully pipelined and
uses less instruction decoding then it may still be worthwhile.

   On the x86 chips, MMX has so far found a use in 'mpn_rshift' and
'mpn_lshift', and is used in a special case for 16-bit multipliers in
the P55 'mpn_mul_1'.  SSE2 is used for Pentium 4 'mpn_mul_1',
'mpn_addmul_1', and 'mpn_submul_1'.


File: mpir.info,  Node: Assembler Software Pipelining,  Next: Assembler Loop Unrolling,  Prev: Assembler SIMD Instructions,  Up: Assembler Coding

16.8.8 Software Pipelining
--------------------------

Software pipelining consists of scheduling instructions around the
branch point in a loop.  For example a loop might issue a load not for
use in the present iteration but the next, thereby allowing extra cycles
for the data to arrive from memory.

   Naturally this is wanted only when doing things like loads or
multiplies that take several cycles to complete, and only where a CPU
has multiple functional units so that other work can be done in the
meantime.

   A pipeline with several stages will have a data value in progress at
each stage and each loop iteration moves them along one stage.  This is
like juggling.

   If the latency of some instruction is greater than the loop time then
it will be necessary to unroll, so one register has a result ready to
use while another (or multiple others) are still in progress.  (*note
Assembler Loop Unrolling::).


File: mpir.info,  Node: Assembler Loop Unrolling,  Next: Assembler Writing Guide,  Prev: Assembler Software Pipelining,  Up: Assembler Coding

16.8.9 Loop Unrolling
---------------------

Loop unrolling consists of replicating code so that several limbs are
processed in each loop.  At a minimum this reduces loop overheads by a
corresponding factor, but it can also allow better register usage, for
example alternately using one register combination and then another.
Judicious use of 'm4' macros can help avoid lots of duplication in the
source code.

   Any amount of unrolling can be handled with a loop counter that's
decremented by N each time, stopping when the remaining count is less
than the further N the loop will process.  Or by subtracting N at the
start, the termination condition becomes when the counter C is less than
0 (and the count of remaining limbs is C+N).

   Alternately for a power of 2 unroll the loop count and remainder can
be established with a shift and mask.  This is convenient if also making
a computed jump into the middle of a large loop.

   The limbs not a multiple of the unrolling can be handled in various
ways, for example

   * A simple loop at the end (or the start) to process the excess.
     Care will be wanted that it isn't too much slower than the unrolled
     part.

   * A set of binary tests, for example after an 8-limb unrolling, test
     for 4 more limbs to process, then a further 2 more or not, and
     finally 1 more or not.  This will probably take more code space
     than a simple loop.

   * A 'switch' statement, providing separate code for each possible
     excess, for example an 8-limb unrolling would have separate code
     for 0 remaining, 1 remaining, etc, up to 7 remaining.  This might
     take a lot of code, but may be the best way to optimize all cases
     in combination with a deep pipelined loop.

   * A computed jump into the middle of the loop, thus making the first
     iteration handle the excess.  This should make times smoothly
     increase with size, which is attractive, but setups for the jump
     and adjustments for pointers can be tricky and could become quite
     difficult in combination with deep pipelining.


File: mpir.info,  Node: Assembler Writing Guide,  Prev: Assembler Loop Unrolling,  Up: Assembler Coding

16.8.10 Writing Guide
---------------------

This is a guide to writing software pipelined loops for processing limb
vectors in assembler.

   First determine the algorithm and which instructions are needed.
Code it without unrolling or scheduling, to make sure it works.  On a
3-operand CPU try to write each new value to a new register, this will
greatly simplify later steps.

   Then note for each instruction the functional unit and/or issue port
requirements.  If an instruction can use either of two units, like U0 or
U1 then make a category "U0/U1".  Count the total using each unit (or
combined unit), and count all instructions.

   Figure out from those counts the best possible loop time.  The goal
will be to find a perfect schedule where instruction latencies are
completely hidden.  The total instruction count might be the limiting
factor, or perhaps a particular functional unit.  It might be possible
to tweak the instructions to help the limiting factor.

   Suppose the loop time is N, then make N issue buckets, with the final
loop branch at the end of the last.  Now fill the buckets with dummy
instructions using the functional units desired.  Run this to make sure
the intended speed is reached.

   Now replace the dummy instructions with the real instructions from
the slow but correct loop you started with.  The first will typically be
a load instruction.  Then the instruction using that value is placed in
a bucket an appropriate distance down.  Run the loop again, to check it
still runs at target speed.

   Keep placing instructions, frequently measuring the loop.  After a
few you will need to wrap around from the last bucket back to the top of
the loop.  If you used the new-register for new-value strategy above
then there will be no register conflicts.  If not then take care not to
clobber something already in use.  Changing registers at this time is
very error prone.

   The loop will overlap two or more of the original loop iterations,
and the computation of one vector element result will be started in one
iteration of the new loop, and completed one or several iterations
later.

   The final step is to create feed-in and wind-down code for the loop.
A good way to do this is to make a copy (or copies) of the loop at the
start and delete those instructions which don't have valid antecedents,
and at the end replicate and delete those whose results are unwanted
(including any further loads).

   The loop will have a minimum number of limbs loaded and processed, so
the feed-in code must test if the request size is smaller and skip
either to a suitable part of the wind-down or to special code for small
sizes.


File: mpir.info,  Node: Internals,  Next: Contributors,  Prev: Algorithms,  Up: Top

17 Internals
************

*This chapter is provided only for informational purposes and the
various internals described here may change in future MPIR releases.
Applications expecting to be compatible with future releases should use
only the documented interfaces described in previous chapters.*

* Menu:

* Integer Internals::
* Rational Internals::
* Float Internals::
* Raw Output Internals::
* C++ Interface Internals::


File: mpir.info,  Node: Integer Internals,  Next: Rational Internals,  Prev: Internals,  Up: Internals

17.1 Integer Internals
======================

'mpz_t' variables represent integers using sign and magnitude, in space
dynamically allocated and reallocated.  The fields are as follows.

'_mp_size'
     The number of limbs, or the negative of that when representing a
     negative integer.  Zero is represented by '_mp_size' set to zero,
     in which case the '_mp_d' data is unused.

'_mp_d'
     A pointer to an array of limbs which is the magnitude.  These are
     stored "little endian" as per the 'mpn' functions, so '_mp_d[0]' is
     the least significant limb and '_mp_d[ABS(_mp_size)-1]' is the most
     significant.  Whenever '_mp_size' is non-zero, the most significant
     limb is non-zero.

     Currently there's always at least one limb allocated, so for
     instance 'mpz_set_ui' never needs to reallocate, and 'mpz_get_ui'
     can fetch '_mp_d[0]' unconditionally (though its value is then only
     wanted if '_mp_size' is non-zero).

'_mp_alloc'
     '_mp_alloc' is the number of limbs currently allocated at '_mp_d',
     and naturally '_mp_alloc >= ABS(_mp_size)'.  When an 'mpz' routine
     is about to (or might be about to) increase '_mp_size', it checks
     '_mp_alloc' to see whether there's enough space, and reallocates if
     not.  'MPZ_REALLOC' is generally used for this.

   The various bitwise logical functions like 'mpz_and' behave as if
negative values were twos complement.  But sign and magnitude is always
used internally, and necessary adjustments are made during the
calculations.  Sometimes this isn't pretty, but sign and magnitude are
best for other routines.

   Some internal temporary variables are setup with 'MPZ_TMP_INIT' and
these have '_mp_d' space obtained from 'TMP_ALLOC' rather than the
memory allocation functions.  Care is taken to ensure that these are big
enough that no reallocation is necessary (since it would have
unpredictable consequences).

   '_mp_size' and '_mp_alloc' are 'int', although 'mp_size_t' is usually
a 'long'.  This is done to make the fields just 32 bits on some 64 bits
systems, thereby saving a few bytes of data space but still providing
plenty of range.


File: mpir.info,  Node: Rational Internals,  Next: Float Internals,  Prev: Integer Internals,  Up: Internals

17.2 Rational Internals
=======================

'mpq_t' variables represent rationals using an 'mpz_t' numerator and
denominator (*note Integer Internals::).

   The canonical form adopted is denominator positive (and non-zero), no
common factors between numerator and denominator, and zero uniquely
represented as 0/1.

   It's believed that casting out common factors at each stage of a
calculation is best in general.  A GCD is an O(N^2) operation so it's
better to do a few small ones immediately than to delay and have to do a
big one later.  Knowing the numerator and denominator have no common
factors can be used for example in 'mpq_mul' to make only two cross GCDs
necessary, not four.

   This general approach to common factors is badly sub-optimal in the
presence of simple factorizations or little prospect for cancellation,
but MPIR has no way to know when this will occur.  As per *note
Efficiency::, that's left to applications.  The 'mpq_t' framework might
still suit, with 'mpq_numref' and 'mpq_denref' for direct access to the
numerator and denominator, or of course 'mpz_t' variables can be used
directly.


File: mpir.info,  Node: Float Internals,  Next: Raw Output Internals,  Prev: Rational Internals,  Up: Internals

17.3 Float Internals
====================

Efficient calculation is the primary aim of MPIR floats and the use of
whole limbs and simple rounding facilitates this.

   'mpf_t' floats have a variable precision mantissa and a single
machine word signed exponent.  The mantissa is represented using sign
and magnitude.

        most                   least
     significant            significant
        limb                   limb

                                 _mp_d
      |---- _mp_exp --->           |
       _____ _____ _____ _____ _____
      |_____|_____|_____|_____|_____|
                        . <------------ radix point

       <-------- _mp_size --------->


The fields are as follows.

'_mp_size'
     The number of limbs currently in use, or the negative of that when
     representing a negative value.  Zero is represented by '_mp_size'
     and '_mp_exp' both set to zero, and in that case the '_mp_d' data
     is unused.  (In the future '_mp_exp' might be undefined when
     representing zero.)

'_mp_prec'
     The precision of the mantissa, in limbs.  In any calculation the
     aim is to produce '_mp_prec' limbs of result (the most significant
     being non-zero).

'_mp_d'
     A pointer to the array of limbs which is the absolute value of the
     mantissa.  These are stored "little endian" as per the 'mpn'
     functions, so '_mp_d[0]' is the least significant limb and
     '_mp_d[ABS(_mp_size)-1]' the most significant.

     The most significant limb is always non-zero, but there are no
     other restrictions on its value, in particular the highest 1 bit
     can be anywhere within the limb.

     '_mp_prec+1' limbs are allocated to '_mp_d', the extra limb being
     for convenience (see below).  There are no reallocations during a
     calculation, only in a change of precision with 'mpf_set_prec'.

'_mp_exp'
     The exponent, in limbs, determining the location of the implied
     radix point.  Zero means the radix point is just above the most
     significant limb.  Positive values mean a radix point offset
     towards the lower limbs and hence a value >= 1, as for example in
     the diagram above.  Negative exponents mean a radix point further
     above the highest limb.

     Naturally the exponent can be any value, it doesn't have to fall
     within the limbs as the diagram shows, it can be a long way above
     or a long way below.  Limbs other than those included in the
     '{_mp_d,_mp_size}' data are treated as zero.

   '_mp_size' and '_mp_prec' are 'int', although 'mp_size_t' is usually
a 'long'.  This is done to make the fields just 32 bits on some 64 bits
systems, thereby saving a few bytes of data space but still providing
plenty of range.


The following various points should be noted.

Low Zeros
     The least significant limbs '_mp_d[0]' etc can be zero, though such
     low zeros can always be ignored.  Routines likely to produce low
     zeros check and avoid them to save time in subsequent calculations,
     but for most routines they're quite unlikely and aren't checked.

Mantissa Size Range
     The '_mp_size' count of limbs in use can be less than '_mp_prec' if
     the value can be represented in less.  This means low precision
     values or small integers stored in a high precision 'mpf_t' can
     still be operated on efficiently.

     '_mp_size' can also be greater than '_mp_prec'.  Firstly a value is
     allowed to use all of the '_mp_prec+1' limbs available at '_mp_d',
     and secondly when 'mpf_set_prec_raw' lowers '_mp_prec' it leaves
     '_mp_size' unchanged and so the size can be arbitrarily bigger than
     '_mp_prec'.

Rounding
     All rounding is done on limb boundaries.  Calculating '_mp_prec'
     limbs with the high non-zero will ensure the application requested
     minimum precision is obtained.

     The use of simple "trunc" rounding towards zero is efficient, since
     there's no need to examine extra limbs and increment or decrement.

Bit Shifts
     Since the exponent is in limbs, there are no bit shifts in basic
     operations like 'mpf_add' and 'mpf_mul'.  When differing exponents
     are encountered all that's needed is to adjust pointers to line up
     the relevant limbs.

     Of course 'mpf_mul_2exp' and 'mpf_div_2exp' will require bit
     shifts, but the choice is between an exponent in limbs which
     requires shifts there, or one in bits which requires them almost
     everywhere else.

Use of '_mp_prec+1' Limbs
     The extra limb on '_mp_d' ('_mp_prec+1' rather than just
     '_mp_prec') helps when an 'mpf' routine might get a carry from its
     operation.  'mpf_add' for instance will do an 'mpn_add' of
     '_mp_prec' limbs.  If there's no carry then that's the result, but
     if there is a carry then it's stored in the extra limb of space and
     '_mp_size' becomes '_mp_prec+1'.

     Whenever '_mp_prec+1' limbs are held in a variable, the low limb is
     not needed for the intended precision, only the '_mp_prec' high
     limbs.  But zeroing it out or moving the rest down is unnecessary.
     Subsequent routines reading the value will simply take the high
     limbs they need, and this will be '_mp_prec' if their target has
     that same precision.  This is no more than a pointer adjustment,
     and must be checked anyway since the destination precision can be
     different from the sources.

     Copy functions like 'mpf_set' will retain a full '_mp_prec+1' limbs
     if available.  This ensures that a variable which has '_mp_size'
     equal to '_mp_prec+1' will get its full exact value copied.
     Strictly speaking this is unnecessary since only '_mp_prec' limbs
     are needed for the application's requested precision, but it's
     considered that an 'mpf_set' from one variable into another of the
     same precision ought to produce an exact copy.

Application Precisions
     '__GMPF_BITS_TO_PREC' converts an application requested precision
     to an '_mp_prec'.  The value in bits is rounded up to a whole limb
     then an extra limb is added since the most significant limb of
     '_mp_d' is only non-zero and therefore might contain only one bit.

     '__GMPF_PREC_TO_BITS' does the reverse conversion, and removes the
     extra limb from '_mp_prec' before converting to bits.  The net
     effect of reading back with 'mpf_get_prec' is simply the precision
     rounded up to a multiple of 'mp_bits_per_limb'.

     Note that the extra limb added here for the high only being
     non-zero is in addition to the extra limb allocated to '_mp_d'.
     For example with a 32-bit limb, an application request for 250 bits
     will be rounded up to 8 limbs, then an extra added for the high
     being only non-zero, giving an '_mp_prec' of 9.  '_mp_d' then gets
     10 limbs allocated.  Reading back with 'mpf_get_prec' will take
     '_mp_prec' subtract 1 limb and multiply by 32, giving 256 bits.

     Strictly speaking, the fact the high limb has at least one bit
     means that a float with, say, 3 limbs of 32-bits each will be
     holding at least 65 bits, but for the purposes of 'mpf_t' it's
     considered simply to be 64 bits, a nice multiple of the limb size.


File: mpir.info,  Node: Raw Output Internals,  Next: C++ Interface Internals,  Prev: Float Internals,  Up: Internals

17.4 Raw Output Internals
=========================

'mpz_out_raw' uses the following format.

     +------+------------------------+
     | size |       data bytes       |
     +------+------------------------+

   The size is 4 bytes written most significant byte first, being the
number of subsequent data bytes, or the twos complement negative of that
when a negative integer is represented.  The data bytes are the absolute
value of the integer, written most significant byte first.

   The most significant data byte is always non-zero, so the output is
the same on all systems, irrespective of limb size.

   In GMP 1, leading zero bytes were written to pad the data bytes to a
multiple of the limb size.  'mpz_inp_raw' will still accept this, for
compatibility.

   The use of "big endian" for both the size and data fields is
deliberate, it makes the data easy to read in a hex dump of a file.
Unfortunately it also means that the limb data must be reversed when
reading or writing, so neither a big endian nor little endian system can
just read and write '_mp_d'.


File: mpir.info,  Node: C++ Interface Internals,  Prev: Raw Output Internals,  Up: Internals

17.5 C++ Interface Internals
============================

A system of expression templates is used to ensure something like
'a=b+c' turns into a simple call to 'mpz_add' etc.  For 'mpf_class' the
scheme also ensures the precision of the final destination is used for
any temporaries within a statement like 'f=w*x+y*z'.  These are
important features which a naive implementation cannot provide.

   A simplified description of the scheme follows.  The true scheme is
complicated by the fact that expressions have different return types.
For detailed information, refer to the source code.

   To perform an operation, say, addition, we first define a "function
object" evaluating it,

     struct __gmp_binary_plus
     {
       static void eval(mpf_t f, mpf_t g, mpf_t h) { mpf_add(f, g, h); }
     };

And an "additive expression" object,

     __gmp_expr<__gmp_binary_expr<mpf_class, mpf_class, __gmp_binary_plus> >
     operator+(const mpf_class &f, const mpf_class &g)
     {
       return __gmp_expr
         <__gmp_binary_expr<mpf_class, mpf_class, __gmp_binary_plus> >(f, g);
     }

   The seemingly redundant '__gmp_expr<__gmp_binary_expr<...>>' is used
to encapsulate any possible kind of expression into a single template
type.  In fact even 'mpf_class' etc are 'typedef' specializations of
'__gmp_expr'.

   Next we define assignment of '__gmp_expr' to 'mpf_class'.

     template <class T>
     mpf_class & mpf_class::operator=(const __gmp_expr<T> &expr)
     {
       expr.eval(this->get_mpf_t(), this->precision());
       return *this;
     }

     template <class Op>
     void __gmp_expr<__gmp_binary_expr<mpf_class, mpf_class, Op> >::eval
     (mpf_t f, mp_bitcnt_t precision)
     {
       Op::eval(f, expr.val1.get_mpf_t(), expr.val2.get_mpf_t());
     }

   where 'expr.val1' and 'expr.val2' are references to the expression's
operands (here 'expr' is the '__gmp_binary_expr' stored within the
'__gmp_expr').

   This way, the expression is actually evaluated only at the time of
assignment, when the required precision (that of 'f') is known.
Furthermore the target 'mpf_t' is now available, thus we can call
'mpf_add' directly with 'f' as the output argument.

   Compound expressions are handled by defining operators taking
subexpressions as their arguments, like this:

     template <class T, class U>
     __gmp_expr
     <__gmp_binary_expr<__gmp_expr<T>, __gmp_expr<U>, __gmp_binary_plus> >
     operator+(const __gmp_expr<T> &expr1, const __gmp_expr<U> &expr2)
     {
       return __gmp_expr
         <__gmp_binary_expr<__gmp_expr<T>, __gmp_expr<U>, __gmp_binary_plus> >
         (expr1, expr2);
     }

   And the corresponding specializations of '__gmp_expr::eval':

     template <class T, class U, class Op>
     void __gmp_expr
     <__gmp_binary_expr<__gmp_expr<T>, __gmp_expr<U>, Op> >::eval
     (mpf_t f, mp_bitcnt_t precision)
     {
       // declare two temporaries
       mpf_class temp1(expr.val1, precision), temp2(expr.val2, precision);
       Op::eval(f, temp1.get_mpf_t(), temp2.get_mpf_t());
     }

   The expression is thus recursively evaluated to any level of
complexity and all subexpressions are evaluated to the precision of 'f'.


File: mpir.info,  Node: Contributors,  Next: References,  Prev: Internals,  Up: Top

Appendix A Contributors
***********************

Torbjorn Granlund wrote the original GMP library and is still developing
and maintaining it.  Several other individuals and organizations have
contributed to GMP in various ways.  Here is a list in chronological
order:

   Gunnar Sjoedin and Hans Riesel helped with mathematical problems in
early versions of the library.

   Richard Stallman contributed to the interface design and revised the
first version of this manual.

   Brian Beuning and Doug Lea helped with testing of early versions of
the library and made creative suggestions.

   John Amanatides of York University in Canada contributed the function
'mpz_probab_prime_p'.

   Paul Zimmermann of Inria sparked the development of GMP 2, with his
comparisons between bignum packages.

   Ken Weber (Kent State University, Universidade Federal do Rio Grande
do Sul) contributed 'mpz_gcd', 'mpz_divexact', 'mpn_gcd', and
'mpn_bdivmod', partially supported by CNPq (Brazil) grant 301314194-2.

   Per Bothner of Cygnus Support helped to set up GMP to use Cygnus'
configure.  He has also made valuable suggestions and tested numerous
intermediary releases.

   Joachim Hollman was involved in the design of the 'mpf' interface,
and in the 'mpz' design revisions for version 2.

   Bennet Yee contributed the initial versions of 'mpz_jacobi' and
'mpz_legendre'.

   Andreas Schwab contributed the files 'mpn/m68k/lshift.S' and
'mpn/m68k/rshift.S' (now in '.asm' form).

   The development of floating point functions of GNU MP 2, were
supported in part by the ESPRIT-BRA (Basic Research Activities) 6846
project POSSO (POlynomial System SOlving).

   GNU MP 2 was finished and released by SWOX AB, SWEDEN, in cooperation
with the IDA Center for Computing Sciences, USA.

   Robert Harley of Inria, France and David Seal of ARM, England,
suggested clever improvements for population count.

   Robert Harley also wrote highly optimized Karatsuba and 3-way Toom
multiplication functions for GMP 3.  He also contributed the ARM
assembly code.

   Torsten Ekedahl of the Mathematical department of Stockholm
University provided significant inspiration during several phases of the
GMP development.  His mathematical expertise helped improve several
algorithms.

   Paul Zimmermann wrote the Divide and Conquer division code, the REDC
code, the REDC-based mpz_powm code, the FFT multiply code, and the
Karatsuba square root code.  He also rewrote the Toom3 code for GMP 4.2.
The ECMNET project Paul is organizing was a driving force behind many of
the optimizations in GMP 3.

   Linus Nordberg wrote the new configure system based on autoconf and
implemented the new random functions.

   Kent Boortz made the Mac OS 9 port.

   Kevin Ryde worked on a number of things: optimized x86 code, m4 asm
macros, parameter tuning, speed measuring, the configure system,
function inlining, divisibility tests, bit scanning, Jacobi symbols,
Fibonacci and Lucas number functions, printf and scanf functions, perl
interface, demo expression parser, the algorithms chapter in the manual,
'gmpasm-mode.el', and various miscellaneous improvements elsewhere.

   Steve Root helped write the optimized alpha 21264 assembly code.

   Gerardo Ballabio wrote the 'gmpxx.h' C++ class interface and the C++
'istream' input routines.

   GNU MP 4 was finished and released by Torbjorn Granlund and Kevin
Ryde.  Torbjorn's work was partially funded by the IDA Center for
Computing Sciences, USA.

   Jason Moxham rewrote 'mpz_fac_ui'.

   Pedro Gimeno implemented the Mersenne Twister and made other random
number improvements.

   (This list is chronological, not ordered after significance.  If you
have contributed to GMP/MPIR but are not listed above, please tell
<http://groups.google.com/group/mpir-devel> about the omission!)

   Thanks go to Hans Thorsen for donating an SGI system for the GMP test
system environment.

   In 2008 GMP was forked and gave rise to the MPIR (Multiple Precision
Integers and Rationals) project.  In 2010 version 2.0.0 of MPIR switched
to LGPL v3+ and much code from GMP was again incorporated into MPIR.

   The MPIR project has largely been a collaboration of William Hart,
Brian Gladman and Jason Moxham.  MPIR code not obtained from GMP and not
specifically mentioned elsewhere below is likely written by one of these
three.

   William Hart did much of the early MPIR coding including build system
fixes.  His contributions also include Toom 4 and 7 code and variants,
extended GCD based on Niels Mollers ngcd work, asymptotically fast
division code.  He does much of the release management work.

   Brian Gladman wrote and maintains MSVC project files.  He has also
done much of the conversion of assembly code to yasm format.  He rewrote
the benchmark program and developed MSVC ports of tune, speed, try and
the benchmark code.  He helped with many aspects of the merging of GMP
code into MPIR after the switch to LGPL v3+.

   Jason Moxham has contributed a great deal of x86 assembly code.  He
has also contributed improved root code and mulhi and mullo routines and
implemented Peter Montgomery's single limb remainder algorithm.  He has
also contributed a command line build system for Windows and numerous
build system fixes.

   The following people have either contributed directly to the MPIR
project, made code available on their websites or contributed code to
the official GNU project which has been used in MPIR.

   Jason Martin wrote some fast assembly patches for Core 2 and
converted them to intel format.  He also did the initial merge of Niels
Moller's fast GCD patches.  He wrote fast addmul functions for Itanium.

   Gonzalo Tornaria helped patch config.guess and associated files to
distinguish modern processors.  He also patched mpirbench.

   Michael Abshoff helped resolve some build issues on various
platforms.  He served for a while as release manager for the MPIR
project.

   Mariah Lennox contributed patches to mpirbench and various build
failure reports.  She has also reported gcc bugs found during MPIR
development.

   Niels Moller wrote the fast ngcd code for computing integer GCD, the
quadratic Hensel division code and precomputed inverse code for
Euclidean division, along with fast jacobi symbols code.  He also made
contributions to the Toom multiply code, especially helper functions to
simplify Toom evaluations.

   Burcin Erocal helped with build testing on Pentium-D

   Pierrick Gaudry provided initial AMD 64 assembly support and revised
the FFT code.

   Paul Zimmermann provided an mpz implementation of Toom 4, wrote much
of the FFT code, wrote some of the rootrem code and contributed invert.c
for computing precomputed inverses.

   Alexander Kruppa revised the FFT code and helped write and
superoptimise assembly code for Skylake, Haswell and Bulldozer and
helped write a superoptimiser.

   Torbjorn Granlund revised the FFT code and wrote a lot of division
code, including the quadratic Euclidean division code, many parts of the
divide and conquer division code, both Hensel and Euclidean, and his
code was also reused for parts of the asymptotically fast division code.
He also helped write the root code and wrote much of the Itanium
assembly code and a couple of Core 2 assembly functions and part of the
basecase middle product assembly code for x86 64 bit.  He also wrote the
improved string input and output code and made improvements to the GCD
and extended GCD code.  He also contributed the nextprime code and
coauthored the bin_uiui code.  He also wrote or maintained the binvert,
mullow_n_basecase, powlo, redc_n code and the powm and powm_ui
improvements.  Torbjorn is also responsible for numerous other bits and
pieces that have been used from the GNU project.

   Marco Bodrato and Alberto Zanoni suggested the unbalanced multiply
strategy and found optimal Toom multiplication sequences.

   Marco Bodrato wrote an mpz implementation of the Toom 7 code and
wrote most of the Toom 8.5 multiply and squaring code.  He also helped
write the divide and conquer Euclidean division code.  He also
contributed many improved number theoretical functions including
factorial, multi-factorial, primorial, n-choose-k.

   Marc Glisse improved gmpxx.h

   Robert Gerbicz contributed fast factorial code.

   Martin Boij made assorted contributions to the nextprime code.

   David Harvey wrote fast middle product code and divide and conquer
approximate quotient code for both Euclidean and Hensel division and
contributed to the quadratic Hensel code.

   T. R. Nicely wrote primality tests used in the benchmark code.

   Jeff Gilchrist assisted with the porting of T. R. Nicely's primality
code to MPIR and helped with tuning.

   David Kirkby helped with build testing on Sun servers

   Peter Shrimpton wrote the BPSW primality test used up to
GMP_LIMB_BITS.

   Thanks to Microsoft for supporting Jason Moxham to work on a command
line build system for Windows and some assembly improvements for
Windows.

   Thanks to William Stein for giving us access to his sage.math
machines for testing and for hosting the MPIR website, and for
supporting us in inumerably many other ways.

   Minh Van Nguyen served as release manager for MPIR 2.1.0.

   Case Vanhorsen helped with release testing.

   David Cleaver filed a bug report.

   Julien Puydt provided tuning values.

   Leif Lionhardy supplied build patches and provided tuning values.

   Jean-Pierre Flori ported the powm, powm_ui improvements from GMP,
supplied many build system patches and improvements and provided tuning
values.

   Thanks to an anonymous Japanese contributor for assembly improvements

   Marshall Hampton reported an issue on apple machines

   Jens Nurmann contributed significant quantities of Skylake assembly
code and contributed assembly improvements that have been used
elsewhere.

   Alex Best wrote an assembly superoptimiser.

   Vincent Delecroix ported mpq_cmp_z from GMP.

   Sisyphus (Rob) submitted tuning values.

   sav-ix (Alexander) provided a patch for t-locale on Windows.

   Isurus Fernando provided tuning values, numerous build system
patches, did release testing and helped with continuous integration.

   Alex Dyachenko wrote mpir.net for interfacing MPIR to .net languages.

   Tommy Hoffman supplied a sed patch.

   Averkhaturau fixed a C++ compilation problem.

   Marcell Keller fixed a sign conversion bug.

   Sergey Taymanov fixed some Windows build file issues.

   jengelh reported a bug and helped with build testing


File: mpir.info,  Node: References,  Next: GNU Free Documentation License,  Prev: Contributors,  Up: Top

Appendix B References
*********************

B.1 Books
=========

   * Jonathan M. Borwein and Peter B. Borwein, "Pi and the AGM: A Study
     in Analytic Number Theory and Computational Complexity", Wiley,
     1998.

   * Henri Cohen, "A Course in Computational Algebraic Number Theory",
     Graduate Texts in Mathematics number 138, Springer-Verlag, 1993.
     <http://www.math.u-bordeaux.fr/~cohen/>

   * Richard Crandall, Carl Pomerance, "Prime Numbers: A Computational
     Perspective" 2nd edition, Springer, 2005.

   * Donald E. Knuth, "The Art of Computer Programming", volume 2,
     "Seminumerical Algorithms", 3rd edition, Addison-Wesley, 1998.
     <http://www-cs-faculty.stanford.edu/~knuth/taocp.html>

   * John D. Lipson, "Elements of Algebra and Algebraic Computing", The
     Benjamin Cummings Publishing Company Inc, 1981.

   * Alfred J. Menezes, Paul C. van Oorschot and Scott A. Vanstone,
     "Handbook of Applied Cryptography",
     <http://www.cacr.math.uwaterloo.ca/hac/>

   * Richard M. Stallman, "Using and Porting GCC", Free Software
     Foundation, 1999, available online
     <http://gcc.gnu.org/onlinedocs/>, and in the GCC package
     <ftp://ftp.gnu.org/gnu/gcc/>

B.2 Papers
==========

   * Dan Bernstein, "Detecting perfect powers in essentially linear
     time", Math.  Comp.  (67) pp. 1253-1283, 1998.

   * Yves Bertot, Nicolas Magaud and Paul Zimmermann, "A Proof of GMP
     Square Root", Journal of Automated Reasoning, volume 29, 2002, pp.
     225-252.  Also available online as INRIA Research Report 4475, June
     2001, <http://www.inria.fr/rrrt/rr-4475.html>

   * Marco Bodrato, Alberto Zanoni, "Integer and Polynomial
     Multiplication: Towards optimal Toom-Cook Matrices", ISAAC 2007
     Proceedings, Ontario, Canada, July 29 - August 1, 2007, ACM Press.
     Available online at <http://ln.bodrato.it/issac2007_pdf>

   * Marco Bodrato, "High degree Toom'n'half for balanced and unbalanced
     multiplication", E. Antelo, D. Hough and P. Ienne, editors,
     Proceedings of the 20th IEEE Symposium on Computer Arithmetic,
     IEEE, Tubingen, Germany, July 25-27, 2011, pp.  15-222.  See
     <http://bodrato.it/papers>

   * Richard Brent and Paul Zimmermann, "Modern Computer Arithmetic",
     version 0.4, November 2009,
     <http://www.loria.fr/~zimmerma/mca/mca-0.4.pdf>

   * Christoph Burnikel and Joachim Ziegler, "Fast Recursive Division",
     Max-Planck-Institut fuer Informatik Research Report MPI-I-98-1-022,
     <http://data.mpi-sb.mpg.de/internet/reports.nsf/NumberView/1998-1-022>

   * Agner Fog, "Software optimization resources", online at
     <http://www.agner.org/optimize/>

   * Pierrick Gaudry, Alexander Kruppa, Paul Zimmermann, "A GMP-based
     implementation of Schoenhage-Strassen's large integer
     multiplication algorithm", ISAAC 2007 Proceedings, Ontario, Canada,
     July 29 - August 1, 2007, pp. 167-174, ACM Press.  Full text
     available at
     <http://hal.inria.fr/docs/00/14/86/20/PDF/fft.final.pdf>

   * Torbjorn Granlund and Peter L. Montgomery, "Division by Invariant
     Integers using Multiplication", in Proceedings of the SIGPLAN
     PLDI'94 Conference, June 1994.  Also available
     <ftp://ftp.cwi.nl/pub/pmontgom/divcnst.psa4.gz> (and .psl.gz).

   * Niels Mo"ller and Torbjo"rn Granlund, "Improved division by
     invariant integers", to appear.

   * Torbjo"rn Granlund and Niels Mo"ller, "Division of integers large
     and small", to appear.

   * David Harvey, "The Karatsuba middle product for integers",
     (preprint), 2009.  Available at
     <http://www.cims.nyu.edu/~harvey/mulmid/mulmid.pdf>

   * Tudor Jebelean, "An algorithm for exact division", Journal of
     Symbolic Computation, volume 15, 1993, pp. 169-180.  Research
     report version available
     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-35.ps.gz>

   * Tudor Jebelean, "Exact Division with Karatsuba Complexity -
     Extended Abstract", RISC-Linz technical report 96-31,
     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-31.ps.gz>

   * Tudor Jebelean, "Practical Integer Division with Karatsuba
     Complexity", ISSAC 97, pp. 339-341.  Technical report available
     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1996/96-29.ps.gz>

   * Tudor Jebelean, "A Generalization of the Binary GCD Algorithm",
     ISSAC 93, pp. 111-116.  Technical report version available
     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1993/93-01.ps.gz>

   * Tudor Jebelean, "A Double-Digit Lehmer-Euclid Algorithm for Finding
     the GCD of Long Integers", Journal of Symbolic Computation, volume
     19, 1995, pp. 145-157.  Technical report version also available
     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1992/92-69.ps.gz>

   * Werner Krandick, Jeremy R. Johnson, "Efficient Multiprecision
     Floating Point Multiplication with Exact Rounding", Technical
     Report, RISC Linz, 1993, available at
     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1993/93-76.ps.gz>

   * Werner Krandick and Tudor Jebelean, "Bidirectional Exact Integer
     Division", Journal of Symbolic Computation, volume 21, 1996, pp.
     441-455.  Early technical report version also available
     <ftp://ftp.risc.uni-linz.ac.at/pub/techreports/1994/94-50.ps.gz>

   * Makoto Matsumoto and Takuji Nishimura, "Mersenne Twister: A
     623-dimensionally equidistributed uniform pseudorandom number
     generator", ACM Transactions on Modelling and Computer Simulation,
     volume 8, January 1998, pp. 3-30.  Available online
     <http://www.math.keio.ac.jp/~nisimura/random/doc/mt.ps.gz> (or
     .pdf)

   * R. Moenck and A. Borodin, "Fast Modular Transforms via Division",
     Proceedings of the 13th Annual IEEE Symposium on Switching and
     Automata Theory, October 1972, pp. 90-96.  Reprinted as "Fast
     Modular Transforms", Journal of Computer and System Sciences,
     volume 8, number 3, June 1974, pp. 366-386.

   * Niels Mo"ller, "On Schoenhage's algorithm and subquadratic integer
     GCD computation", Math.  Comp.  2007.  Available online at
     <http://www.lysator.liu.se/~nisse/archive/S0025-5718-07-02017-0.pdf>

   * Peter L. Montgomery, "Modular Multiplication Without Trial
     Division", in Mathematics of Computation, volume 44, number 170,
     April 1985.

   * Thom Mulders, "On short multiplications and divisions", Appl.
     Algebra Engrg.  Comm.  Comput.  11 (2000), no.  1, pp. 69-88.
     Tech.  report No.  276, Dept.  of Comp.  Sci., ETH Zurich, Nov
     1997, available online at
     <ftp://ftp.inf.ethz.ch/pub/publications/tech-reports/2xx/276.pdf>

   * Arnold Scho"nhage and Volker Strassen, "Schnelle Multiplikation
     grosser Zahlen", Computing 7, 1971, pp. 281-292.

   * A. Scho"nhage, A. F. W. Grotefeld and E. Vetter, "Fast Algorithms,
     A Multitape Turing Machine Implementation" BI Wissenschafts-Verlag,
     Mannheim, 1994.

   * Kenneth Weber, "The accelerated integer GCD algorithm", ACM
     Transactions on Mathematical Software, volume 21, number 1, March
     1995, pp. 111-122.

   * Paul Zimmermann, "Karatsuba Square Root", INRIA Research Report
     3805, November 1999, <http://www.inria.fr/rrrt/rr-3805.html>

   * Paul Zimmermann, "A Proof of GMP Fast Division and Square Root
     Implementations",
     <http://www.loria.fr/~zimmerma/papers/proof-div-sqrt.ps.gz>

   * Dan Zuras, "On Squaring and Multiplying Large Integers", ARITH-11:
     IEEE Symposium on Computer Arithmetic, 1993, pp. 260 to 271.
     Reprinted as "More on Multiplying and Squaring Large Integers",
     IEEE Transactions on Computers, volume 43, number 8, August 1994,
     pp. 899-908.


File: mpir.info,  Node: GNU Free Documentation License,  Next: Concept Index,  Prev: References,  Up: Top

Appendix C GNU Free Documentation License
*****************************************

                     Version 1.3, 3 November 2008

     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     The "publisher" means any person or entity that distributes copies
     of the Document to the public.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled "History" in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          "History" section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version's
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <http://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     "Incorporate" means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is "eligible for relicensing" if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts."  line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: mpir.info,  Node: Concept Index,  Next: Function Index,  Prev: GNU Free Documentation License,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* '#include':                            Headers and Libraries.
                                                              (line   6)
* '--build':                             Build Options.       (line  60)
* '--disable-fft':                       Build Options.       (line 321)
* '--disable-shared':                    Build Options.       (line  53)
* '--disable-static':                    Build Options.       (line  53)
* '--enable-alloca':                     Build Options.       (line 287)
* '--enable-assert':                     Build Options.       (line 326)
* '--enable-cxx':                        Build Options.       (line 239)
* '--enable-fat':                        Build Options.       (line 163)
* '--enable-gmpcompat':                  Build Options.       (line  45)
* '--enable-profiling':                  Build Options.       (line 330)
* '--enable-profiling' <1>:              Profiling.           (line   6)
* '--exec-prefix':                       Build Options.       (line  32)
* '--host':                              Build Options.       (line  74)
* '--prefix':                            Build Options.       (line  32)
* '--with-yasm':                         Build Options.       (line 182)
* '-finstrument-functions':              Profiling.           (line  66)
* .Net Interface:                        .Net Interface.      (line   6)
* '2exp' functions:                      Efficiency.          (line  43)
* 80x86:                                 Notes for Particular Systems.
                                                              (line  87)
* ABI:                                   Build Options.       (line 171)
* ABI <1>:                               ABI and ISA.         (line   6)
* About this manual:                     Introduction to MPIR.
                                                              (line  48)
* 'AC_CHECK_LIB':                        Autoconf.            (line  11)
* AIX:                                   ABI and ISA.         (line  95)
* AIX <1>:                               ABI and ISA.         (line 103)
* Algorithms:                            Algorithms.          (line   6)
* 'alloca':                              Build Options.       (line 287)
* Allocation of memory:                  Custom Allocation.   (line   6)
* AMD64:                                 ABI and ISA.         (line  45)
* Application Binary Interface:          ABI and ISA.         (line   6)
* Arithmetic functions:                  Integer Arithmetic.  (line   6)
* Arithmetic functions <1>:              Rational Arithmetic. (line   6)
* Arithmetic functions <2>:              Float Arithmetic.    (line   6)
* ARM:                                   Notes for Particular Systems.
                                                              (line   7)
* Assembler cache handling:              Assembler Cache Handling.
                                                              (line   6)
* Assembler carry propagation:           Assembler Carry Propagation.
                                                              (line   6)
* Assembler code organisation:           Assembler Code Organisation.
                                                              (line   6)
* Assembler coding:                      Assembler Coding.    (line   6)
* Assembler floating Point:              Assembler Floating Point.
                                                              (line   6)
* Assembler loop unrolling:              Assembler Loop Unrolling.
                                                              (line   6)
* Assembler SIMD:                        Assembler SIMD Instructions.
                                                              (line   6)
* Assembler software pipelining:         Assembler Software Pipelining.
                                                              (line   6)
* Assembler writing guide:               Assembler Writing Guide.
                                                              (line   6)
* Assertion checking:                    Build Options.       (line 326)
* Assertion checking <1>:                Debugging.           (line  75)
* Assignment functions:                  Assigning Integers.  (line   6)
* Assignment functions <1>:              Simultaneous Integer Init & Assign.
                                                              (line   6)
* Assignment functions <2>:              Initializing Rationals.
                                                              (line   6)
* Assignment functions <3>:              Assigning Floats.    (line   6)
* Assignment functions <4>:              Simultaneous Float Init & Assign.
                                                              (line   6)
* Autoconf:                              Autoconf.            (line   6)
* Basics:                                MPIR Basics.         (line   6)
* Binomial coefficient algorithm:        Binomial Coefficients Algorithm.
                                                              (line   6)
* Binomial coefficient functions:        Number Theoretic Functions.
                                                              (line 173)
* Bit manipulation functions:            Integer Logic and Bit Fiddling.
                                                              (line   6)
* Bit scanning functions:                Integer Logic and Bit Fiddling.
                                                              (line  37)
* Bit shift left:                        Integer Arithmetic.  (line  29)
* Bit shift right:                       Integer Division.    (line  50)
* Bits per limb:                         Useful Macros and Constants.
                                                              (line   7)
* Bug reporting:                         Reporting Bugs.      (line   6)
* Build directory:                       Build Options.       (line  19)
* Build notes for binary packaging:      Notes for Package Builds.
                                                              (line   6)
* Build notes for MSVC:                  Building with Microsoft Visual Studio.
                                                              (line   6)
* Build notes for particular systems:    Notes for Particular Systems.
                                                              (line   6)
* Build options:                         Build Options.       (line   6)
* Build problems known:                  Known Build Problems.
                                                              (line   6)
* Build system:                          Build Options.       (line  60)
* Building MPIR:                         Installing MPIR.     (line   6)
* Bus error:                             Debugging.           (line   7)
* C compiler:                            Build Options.       (line 191)
* C++ compiler:                          Build Options.       (line 263)
* C++ interface:                         C++ Class Interface. (line   6)
* C++ interface internals:               C++ Interface Internals.
                                                              (line   6)
* C++ 'istream' input:                   C++ Formatted Input. (line   6)
* C++ 'ostream' output:                  C++ Formatted Output.
                                                              (line   6)
* C++ support:                           Build Options.       (line 239)
* 'CC':                                  Build Options.       (line 191)
* 'CC_FOR_BUILD':                        Build Options.       (line 226)
* 'CFLAGS':                              Build Options.       (line 191)
* Checker:                               Debugging.           (line 111)
* 'checkergcc':                          Debugging.           (line 118)
* Code organisation:                     Assembler Code Organisation.
                                                              (line   6)
* Comparison functions:                  Integer Comparisons. (line   6)
* Comparison functions <1>:              Comparing Rationals. (line   6)
* Comparison functions <2>:              Float Comparison.    (line   6)
* Compatibility with older versions:     Compatibility with older versions.
                                                              (line   6)
* Conditions for copying MPIR:           Copying.             (line   6)
* Configuring MPIR:                      Installing MPIR.     (line   6)
* Congruence algorithm:                  Exact Remainder.     (line  30)
* Congruence functions:                  Integer Division.    (line 120)
* Constants:                             Useful Macros and Constants.
                                                              (line   6)
* Contributors:                          Contributors.        (line   6)
* Conventions for parameters:            Parameter Conventions.
                                                              (line   6)
* Conventions for variables:             Variable Conventions.
                                                              (line   6)
* Conversion functions:                  Converting Integers. (line   6)
* Conversion functions <1>:              Rational Conversions.
                                                              (line   6)
* Conversion functions <2>:              Converting Floats.   (line   6)
* Copying conditions:                    Copying.             (line   6)
* 'CPPFLAGS':                            Build Options.       (line 217)
* CPU types:                             Introduction to MPIR.
                                                              (line  24)
* CPU types <1>:                         Build Options.       (line 115)
* Cross compiling:                       Build Options.       (line  74)
* Custom allocation:                     Custom Allocation.   (line   6)
* 'CXX':                                 Build Options.       (line 263)
* 'CXXFLAGS':                            Build Options.       (line 263)
* Cygwin:                                Notes for Particular Systems.
                                                              (line  21)
* Debugging:                             Debugging.           (line   6)
* Digits in an integer:                  Miscellaneous Integer Functions.
                                                              (line  23)
* Divisibility algorithm:                Exact Remainder.     (line  30)
* Divisibility functions:                Integer Division.    (line 109)
* Divisibility functions <1>:            Integer Division.    (line 120)
* Divisibility testing:                  Efficiency.          (line  91)
* Division algorithms:                   Division Algorithms. (line   6)
* Division functions:                    Integer Division.    (line   6)
* Division functions <1>:                Rational Arithmetic. (line  22)
* Division functions <2>:                Float Arithmetic.    (line  27)
* DLLs:                                  Notes for Particular Systems.
                                                              (line  34)
* DocBook:                               Build Options.       (line 353)
* Documentation formats:                 Build Options.       (line 346)
* Documentation license:                 GNU Free Documentation License.
                                                              (line   6)
* DVI:                                   Build Options.       (line 349)
* Efficiency:                            Efficiency.          (line   6)
* Emacs:                                 Emacs.               (line   6)
* Exact division functions:              Integer Division.    (line  99)
* Exact remainder:                       Exact Remainder.     (line   6)
* Exec prefix:                           Build Options.       (line  32)
* Execution profiling:                   Build Options.       (line 330)
* Execution profiling <1>:               Profiling.           (line   6)
* Exponentiation functions:              Integer Exponentiation.
                                                              (line   6)
* Exponentiation functions <1>:          Float Arithmetic.    (line  34)
* Export:                                Integer Import and Export.
                                                              (line  45)
* Extended GCD:                          Number Theoretic Functions.
                                                              (line  99)
* Factor removal functions:              Number Theoretic Functions.
                                                              (line 155)
* Factorial algorithm:                   Factorial Algorithm. (line   6)
* Factorial functions:                   Number Theoretic Functions.
                                                              (line 163)
* Fast Fourier Transform:                FFT Multiplication.  (line   6)
* Fat binary:                            Build Options.       (line 163)
* FFT multiplication:                    Build Options.       (line 321)
* FFT multiplication <1>:                FFT Multiplication.  (line   6)
* Fibonacci number algorithm:            Fibonacci Numbers Algorithm.
                                                              (line   6)
* Fibonacci sequence functions:          Number Theoretic Functions.
                                                              (line 180)
* Float arithmetic functions:            Float Arithmetic.    (line   6)
* Float assignment functions:            Assigning Floats.    (line   6)
* Float assignment functions <1>:        Simultaneous Float Init & Assign.
                                                              (line   6)
* Float comparison functions:            Float Comparison.    (line   6)
* Float conversion functions:            Converting Floats.   (line   6)
* Float functions:                       Floating-point Functions.
                                                              (line   6)
* Float initialization functions:        Initializing Floats. (line   6)
* Float initialization functions <1>:    Simultaneous Float Init & Assign.
                                                              (line   6)
* Float input and output functions:      I/O of Floats.       (line   6)
* Float internals:                       Float Internals.     (line   6)
* Float miscellaneous functions:         Miscellaneous Float Functions.
                                                              (line   6)
* Float random number functions:         Miscellaneous Float Functions.
                                                              (line  27)
* Float rounding functions:              Miscellaneous Float Functions.
                                                              (line   9)
* Float sign tests:                      Float Comparison.    (line  28)
* Floating point mode:                   Notes for Particular Systems.
                                                              (line  12)
* Floating-point functions:              Floating-point Functions.
                                                              (line   6)
* Floating-point number:                 Nomenclature and Types.
                                                              (line  21)
* fnccheck:                              Profiling.           (line  77)
* Formatted input:                       Formatted Input.     (line   6)
* Formatted output:                      Formatted Output.    (line   6)
* Free Documentation License:            GNU Free Documentation License.
                                                              (line   6)
* 'frexp':                               Converting Integers. (line  57)
* 'frexp' <1>:                           Converting Floats.   (line  23)
* Function classes:                      Function Classes.    (line   6)
* FunctionCheck:                         Profiling.           (line  77)
* GCC:                                   Known Build Problems.
                                                              (line   9)
* GCC Checker:                           Debugging.           (line 111)
* GCD algorithms:                        Greatest Common Divisor Algorithms.
                                                              (line   6)
* GCD extended:                          Number Theoretic Functions.
                                                              (line  99)
* GCD functions:                         Number Theoretic Functions.
                                                              (line  85)
* GDB:                                   Debugging.           (line  54)
* Generic C:                             Build Options.       (line 152)
* GNU Debugger:                          Debugging.           (line  54)
* GNU Free Documentation License:        GNU Free Documentation License.
                                                              (line   6)
* 'gprof':                               Profiling.           (line  41)
* Greatest common divisor algorithms:    Greatest Common Divisor Algorithms.
                                                              (line   6)
* Greatest common divisor functions:     Number Theoretic Functions.
                                                              (line  85)
* Hardware floating point mode:          Notes for Particular Systems.
                                                              (line  12)
* Headers:                               Headers and Libraries.
                                                              (line   6)
* Heap problems:                         Debugging.           (line  23)
* Home page:                             Introduction to MPIR.
                                                              (line  30)
* Host system:                           Build Options.       (line  74)
* HP-UX:                                 ABI and ISA.         (line  69)
* I/O functions:                         I/O of Integers.     (line   6)
* I/O functions <1>:                     I/O of Rationals.    (line   6)
* I/O functions <2>:                     I/O of Floats.       (line   6)
* i386:                                  Notes for Particular Systems.
                                                              (line  87)
* IA-64:                                 ABI and ISA.         (line  69)
* Import:                                Integer Import and Export.
                                                              (line  11)
* In-place operations:                   Efficiency.          (line  57)
* Include files:                         Headers and Libraries.
                                                              (line   6)
* 'info-lookup-symbol':                  Emacs.               (line   6)
* Initialization functions:              Initializing Integers.
                                                              (line   6)
* Initialization functions <1>:          Simultaneous Integer Init & Assign.
                                                              (line   6)
* Initialization functions <2>:          Initializing Rationals.
                                                              (line   6)
* Initialization functions <3>:          Initializing Floats. (line   6)
* Initialization functions <4>:          Simultaneous Float Init & Assign.
                                                              (line   6)
* Initialization functions <5>:          Random State Initialization.
                                                              (line   6)
* Initializing and clearing:             Efficiency.          (line  21)
* Input functions:                       I/O of Integers.     (line   6)
* Input functions <1>:                   I/O of Rationals.    (line   6)
* Input functions <2>:                   I/O of Floats.       (line   6)
* Input functions <3>:                   Formatted Input Functions.
                                                              (line   6)
* Install prefix:                        Build Options.       (line  32)
* Installing MPIR:                       Installing MPIR.     (line   6)
* Instruction Set Architecture:          ABI and ISA.         (line   6)
* 'instrument-functions':                Profiling.           (line  66)
* Integer:                               Nomenclature and Types.
                                                              (line   6)
* Integer arithmetic functions:          Integer Arithmetic.  (line   6)
* Integer assignment functions:          Assigning Integers.  (line   6)
* Integer assignment functions <1>:      Simultaneous Integer Init & Assign.
                                                              (line   6)
* Integer bit manipulation functions:    Integer Logic and Bit Fiddling.
                                                              (line   6)
* Integer comparison functions:          Integer Comparisons. (line   6)
* Integer conversion functions:          Converting Integers. (line   6)
* Integer division functions:            Integer Division.    (line   6)
* Integer exponentiation functions:      Integer Exponentiation.
                                                              (line   6)
* Integer export:                        Integer Import and Export.
                                                              (line  45)
* Integer functions:                     Integer Functions.   (line   6)
* Integer import:                        Integer Import and Export.
                                                              (line  11)
* Integer initialization functions:      Initializing Integers.
                                                              (line   6)
* Integer initialization functions <1>:  Simultaneous Integer Init & Assign.
                                                              (line   6)
* Integer input and output functions:    I/O of Integers.     (line   6)
* Integer internals:                     Integer Internals.   (line   6)
* Integer logical functions:             Integer Logic and Bit Fiddling.
                                                              (line   6)
* Integer miscellaneous functions:       Miscellaneous Integer Functions.
                                                              (line   6)
* Integer random number functions:       Integer Random Numbers.
                                                              (line   6)
* Integer root functions:                Integer Roots.       (line   6)
* Integer sign tests:                    Integer Comparisons. (line  28)
* Integer special functions:             Integer Special Functions.
                                                              (line   6)
* Internals:                             Internals.           (line   6)
* Introduction:                          Introduction to MPIR.
                                                              (line   6)
* Inverse modulo functions:              Number Theoretic Functions.
                                                              (line 124)
* ISA:                                   ABI and ISA.         (line   6)
* 'istream' input:                       C++ Formatted Input. (line   6)
* Jacobi symbol algorithm:               Jacobi Symbol.       (line   6)
* Jacobi symbol functions:               Number Theoretic Functions.
                                                              (line 130)
* Karatsuba multiplication:              Karatsuba Multiplication.
                                                              (line   6)
* Karatsuba square root algorithm:       Square Root Algorithm.
                                                              (line   6)
* Kronecker symbol functions:            Number Theoretic Functions.
                                                              (line 142)
* Language bindings:                     Language Bindings.   (line   6)
* LCM functions:                         Number Theoretic Functions.
                                                              (line 119)
* Least common multiple functions:       Number Theoretic Functions.
                                                              (line 119)
* Legendre symbol functions:             Number Theoretic Functions.
                                                              (line 133)
* 'libmpir':                             Headers and Libraries.
                                                              (line  22)
* 'libmpirxx':                           Headers and Libraries.
                                                              (line  28)
* Libraries:                             Headers and Libraries.
                                                              (line  22)
* Libtool:                               Headers and Libraries.
                                                              (line  34)
* Libtool versioning:                    Notes for Package Builds.
                                                              (line   9)
* License conditions:                    Copying.             (line   6)
* Limb:                                  Nomenclature and Types.
                                                              (line  31)
* Limb size:                             Useful Macros and Constants.
                                                              (line   7)
* Linear congruential algorithm:         Random Number Algorithms.
                                                              (line  25)
* Linear congruential random numbers:    Random State Initialization.
                                                              (line  19)
* Linear congruential random numbers <1>: Random State Initialization.
                                                              (line  33)
* Linking:                               Headers and Libraries.
                                                              (line  22)
* Logical functions:                     Integer Logic and Bit Fiddling.
                                                              (line   6)
* Low-level functions:                   Low-level Functions. (line   6)
* Lucas number algorithm:                Lucas Numbers Algorithm.
                                                              (line   6)
* Lucas number functions:                Number Theoretic Functions.
                                                              (line 190)
* Mailing lists:                         Introduction to MPIR.
                                                              (line  35)
* Malloc debugger:                       Debugging.           (line  29)
* Malloc problems:                       Debugging.           (line  23)
* Managed Interface:                     .Net Interface.      (line   6)
* Memory allocation:                     Custom Allocation.   (line   6)
* Memory management:                     Memory Management.   (line   6)
* Mersenne twister algorithm:            Random Number Algorithms.
                                                              (line  17)
* Mersenne twister random numbers:       Random State Initialization.
                                                              (line  13)
* Microsoft.Net:                         .Net Interface.      (line   6)
* MINGW:                                 Notes for Particular Systems.
                                                              (line  21)
* Miscellaneous float functions:         Miscellaneous Float Functions.
                                                              (line   6)
* Miscellaneous integer functions:       Miscellaneous Integer Functions.
                                                              (line   6)
* MMX:                                   Notes for Particular Systems.
                                                              (line  93)
* Modular inverse functions:             Number Theoretic Functions.
                                                              (line 124)
* Most significant bit:                  Miscellaneous Integer Functions.
                                                              (line  34)
* MPIR version number:                   Useful Macros and Constants.
                                                              (line  12)
* MPIR version number <1>:               Useful Macros and Constants.
                                                              (line  20)
* 'mpir.h':                              Headers and Libraries.
                                                              (line   6)
* 'mpirxx.h':                            C++ Interface General.
                                                              (line   8)
* 'MPN_PATH':                            Build Options.       (line 334)
* MS Windows:                            Notes for Particular Systems.
                                                              (line  21)
* MS Windows <1>:                        Notes for Particular Systems.
                                                              (line  34)
* MS-DOS:                                Notes for Particular Systems.
                                                              (line  21)
* MSVC:                                  Building with Microsoft Visual Studio.
                                                              (line   6)
* Multi-threading:                       Reentrancy.          (line   6)
* Multiplication algorithms:             Multiplication Algorithms.
                                                              (line   6)
* Nails:                                 Low-level Functions. (line 513)
* Native compilation:                    Build Options.       (line  60)
* Next candidate prime function:         Number Theoretic Functions.
                                                              (line  72)
* Next prime function:                   Number Theoretic Functions.
                                                              (line  60)
* Nomenclature:                          Nomenclature and Types.
                                                              (line   6)
* Non-Unix systems:                      Build Options.       (line  11)
* Nth root algorithm:                    Nth Root Algorithm.  (line   6)
* Number sequences:                      Efficiency.          (line 145)
* Number theoretic functions:            Number Theoretic Functions.
                                                              (line   6)
* Numerator and denominator:             Applying Integer Functions.
                                                              (line   6)
* 'obstack' output:                      Formatted Output Functions.
                                                              (line  79)
* Optimizing performance:                Performance optimization.
                                                              (line   6)
* 'ostream' output:                      C++ Formatted Output.
                                                              (line   6)
* Other languages:                       Language Bindings.   (line   6)
* Output functions:                      I/O of Integers.     (line   6)
* Output functions <1>:                  I/O of Rationals.    (line   6)
* Output functions <2>:                  I/O of Floats.       (line   6)
* Output functions <3>:                  Formatted Output Functions.
                                                              (line   6)
* Packaged builds:                       Notes for Package Builds.
                                                              (line   6)
* Parameter conventions:                 Parameter Conventions.
                                                              (line   6)
* Particular systems:                    Notes for Particular Systems.
                                                              (line   6)
* Past GMP/MPIR versions:                Compatibility with older versions.
                                                              (line   6)
* PDF:                                   Build Options.       (line 349)
* Perfect power algorithm:               Perfect Power Algorithm.
                                                              (line   6)
* Perfect power functions:               Integer Roots.       (line  30)
* Perfect square algorithm:              Perfect Square Algorithm.
                                                              (line   6)
* Perfect square functions:              Integer Roots.       (line  39)
* Postscript:                            Build Options.       (line 349)
* Powering algorithms:                   Powering Algorithms. (line   6)
* Powering functions:                    Integer Exponentiation.
                                                              (line   6)
* Powering functions <1>:                Float Arithmetic.    (line  34)
* PowerPC:                               ABI and ISA.         (line  94)
* Precision of floats:                   Floating-point Functions.
                                                              (line   6)
* Precision of hardware floating point:  Notes for Particular Systems.
                                                              (line  12)
* Prefix:                                Build Options.       (line  32)
* Prime testing algorithms:              Prime Testing Algorithm.
                                                              (line   6)
* Prime testing functions:               Number Theoretic Functions.
                                                              (line   8)
* Prime testing functions <1>:           Number Theoretic Functions.
                                                              (line  26)
* Prime testing functions <2>:           Number Theoretic Functions.
                                                              (line  41)
* Primorial functions:                   Number Theoretic Functions.
                                                              (line 168)
* 'printf' formatted output:             Formatted Output.    (line   6)
* Probable prime testing functions:      Number Theoretic Functions.
                                                              (line   8)
* Probable prime testing functions <1>:  Number Theoretic Functions.
                                                              (line  26)
* Probable prime testing functions <2>:  Number Theoretic Functions.
                                                              (line  41)
* 'prof':                                Profiling.           (line  24)
* Profiling:                             Profiling.           (line   6)
* Radix conversion algorithms:           Radix Conversion Algorithms.
                                                              (line   6)
* Random number algorithms:              Random Number Algorithms.
                                                              (line   6)
* Random number functions:               Integer Random Numbers.
                                                              (line   6)
* Random number functions <1>:           Miscellaneous Float Functions.
                                                              (line  27)
* Random number functions <2>:           Random Number Functions.
                                                              (line   6)
* Random number seeding:                 Random State Seeding.
                                                              (line   6)
* Random number state:                   Random State Initialization.
                                                              (line   6)
* Random state:                          Nomenclature and Types.
                                                              (line  45)
* Rational arithmetic:                   Efficiency.          (line 111)
* Rational arithmetic functions:         Rational Arithmetic. (line   6)
* Rational assignment functions:         Initializing Rationals.
                                                              (line   6)
* Rational comparison functions:         Comparing Rationals. (line   6)
* Rational conversion functions:         Rational Conversions.
                                                              (line   6)
* Rational initialization functions:     Initializing Rationals.
                                                              (line   6)
* Rational input and output functions:   I/O of Rationals.    (line   6)
* Rational internals:                    Rational Internals.  (line   6)
* Rational number:                       Nomenclature and Types.
                                                              (line  16)
* Rational number functions:             Rational Number Functions.
                                                              (line   6)
* Rational numerator and denominator:    Applying Integer Functions.
                                                              (line   6)
* Rational sign tests:                   Comparing Rationals. (line  26)
* Raw output internals:                  Raw Output Internals.
                                                              (line   6)
* Reallocations:                         Efficiency.          (line  30)
* Reentrancy:                            Reentrancy.          (line   6)
* References:                            References.          (line   5)
* Remove factor functions:               Number Theoretic Functions.
                                                              (line 155)
* Reporting bugs:                        Reporting Bugs.      (line   6)
* Root extraction algorithm:             Nth Root Algorithm.  (line   6)
* Root extraction algorithms:            Root Extraction Algorithms.
                                                              (line   6)
* Root extraction functions:             Integer Roots.       (line   6)
* Root extraction functions <1>:         Float Arithmetic.    (line  31)
* Root testing functions:                Integer Roots.       (line  30)
* Root testing functions <1>:            Integer Roots.       (line  39)
* Rounding functions:                    Miscellaneous Float Functions.
                                                              (line   9)
* Scan bit functions:                    Integer Logic and Bit Fiddling.
                                                              (line  37)
* 'scanf' formatted input:               Formatted Input.     (line   6)
* Seeding random numbers:                Random State Seeding.
                                                              (line   6)
* Segmentation violation:                Debugging.           (line   7)
* Shared library versioning:             Notes for Package Builds.
                                                              (line   9)
* Sign tests:                            Integer Comparisons. (line  28)
* Sign tests <1>:                        Comparing Rationals. (line  26)
* Sign tests <2>:                        Float Comparison.    (line  28)
* Size in digits:                        Miscellaneous Integer Functions.
                                                              (line  23)
* Small operands:                        Efficiency.          (line   7)
* Solaris:                               ABI and ISA.         (line 120)
* Solaris <1>:                           Notes for Particular Systems.
                                                              (line  83)
* Sparc:                                 Notes for Particular Systems.
                                                              (line  50)
* Sparc <1>:                             Notes for Particular Systems.
                                                              (line  55)
* Sparc <2>:                             Notes for Particular Systems.
                                                              (line  67)
* Sparc V9:                              ABI and ISA.         (line 120)
* Special integer functions:             Integer Special Functions.
                                                              (line   6)
* Square root algorithm:                 Square Root Algorithm.
                                                              (line   6)
* SSE2:                                  Notes for Particular Systems.
                                                              (line  93)
* Stack backtrace:                       Debugging.           (line  46)
* Stack overflow:                        Build Options.       (line 287)
* Stack overflow <1>:                    Debugging.           (line   7)
* Static linking:                        Efficiency.          (line  14)
* 'stdarg.h':                            Headers and Libraries.
                                                              (line  17)
* 'stdio.h':                             Headers and Libraries.
                                                              (line  11)
* Sun:                                   ABI and ISA.         (line 120)
* Systems:                               Notes for Particular Systems.
                                                              (line   6)
* Temporary memory:                      Build Options.       (line 287)
* Texinfo:                               Build Options.       (line 346)
* Text input/output:                     Efficiency.          (line 151)
* Thread safety:                         Reentrancy.          (line   6)
* Toom multiplication:                   Toom 3-Way Multiplication.
                                                              (line   6)
* Toom multiplication <1>:               Toom 4-Way Multiplication.
                                                              (line   6)
* Toom multiplication <2>:               Other Multiplication.
                                                              (line   6)
* Types:                                 Nomenclature and Types.
                                                              (line   6)
* 'ui' and 'si' functions:               Efficiency.          (line  50)
* Unbalanced multiplication:             Unbalanced Multiplication.
                                                              (line   6)
* Upward compatibility:                  Compatibility with older versions.
                                                              (line   6)
* Useful macros and constants:           Useful Macros and Constants.
                                                              (line   6)
* User-defined precision:                Floating-point Functions.
                                                              (line   6)
* Valgrind:                              Debugging.           (line 126)
* Variable conventions:                  Variable Conventions.
                                                              (line   6)
* Version number:                        Useful Macros and Constants.
                                                              (line  12)
* Version number <1>:                    Useful Macros and Constants.
                                                              (line  20)
* Visual Studio:                         Building with Microsoft Visual Studio.
                                                              (line   6)
* Web page:                              Introduction to MPIR.
                                                              (line  30)
* Windows:                               Notes for Particular Systems.
                                                              (line  21)
* Windows <1>:                           Notes for Particular Systems.
                                                              (line  34)
* Windows <2>:                           MPIR on Windows x64. (line   6)
* x86:                                   Notes for Particular Systems.
                                                              (line  87)
* x87:                                   Notes for Particular Systems.
                                                              (line  12)
* XML:                                   Build Options.       (line 353)
* XOP:                                   Known Build Problems.
                                                              (line   9)
* Yasm:                                  Build Options.       (line 182)


File: mpir.info,  Node: Function Index,  Prev: Concept Index,  Up: Top

Function and Type Index
***********************

 [index ]
* Menu:

* _mpz_realloc:                          Integer Special Functions.
                                                              (line  53)
* __GMP_CC:                              Useful Macros and Constants.
                                                              (line  28)
* __GMP_CFLAGS:                          Useful Macros and Constants.
                                                              (line  29)
* __GNU_MP_VERSION:                      Useful Macros and Constants.
                                                              (line   9)
* __GNU_MP_VERSION_MINOR:                Useful Macros and Constants.
                                                              (line  10)
* __GNU_MP_VERSION_PATCHLEVEL:           Useful Macros and Constants.
                                                              (line  11)
* __MPIR_VERSION:                        Useful Macros and Constants.
                                                              (line  17)
* __MPIR_VERSION_MINOR:                  Useful Macros and Constants.
                                                              (line  18)
* __MPIR_VERSION_PATCHLEVEL:             Useful Macros and Constants.
                                                              (line  19)
* abs:                                   C++ Interface Integers.
                                                              (line  44)
* abs <1>:                               C++ Interface Rationals.
                                                              (line  46)
* abs <2>:                               C++ Interface Floats.
                                                              (line  72)
* Abs:                                   MPIR.Net Integers.   (line 226)
* Abs <1>:                               MPIR.Net Rationals.  (line 199)
* Abs <2>:                               MPIR.Net Floats.     (line 199)
* Allocate:                              MPIR.Net Integers.   (line  53)
* Allocate <1>:                          MPIR.Net Rationals.  (line  64)
* Allocate <2>:                          MPIR.Net Floats.     (line  73)
* AllocatedPrecision:                    MPIR.Net Floats.     (line  78)
* AllocatedSize:                         MPIR.Net Integers.   (line  57)
* ApproximateSizeInBase:                 MPIR.Net Integers.   (line  72)
* ApproximateSizeInBase <1>:             MPIR.Net Rationals.  (line 101)
* Binomial:                              MPIR.Net Integers.   (line 297)
* Binomial <1>:                          MPIR.Net Integers.   (line 299)
* BITS_PER_LIMB:                         MPIR.Net Settings.   (line  10)
* Canonicalize:                          MPIR.Net Rationals.  (line  71)
* ceil:                                  C++ Interface Floats.
                                                              (line  73)
* Ceiling:                               MPIR.Net Floats.     (line 203)
* cmp:                                   C++ Interface Integers.
                                                              (line  45)
* cmp <1>:                               C++ Interface Integers.
                                                              (line  46)
* cmp <2>:                               C++ Interface Rationals.
                                                              (line  47)
* cmp <3>:                               C++ Interface Rationals.
                                                              (line  48)
* cmp <4>:                               C++ Interface Floats.
                                                              (line  74)
* cmp <5>:                               C++ Interface Floats.
                                                              (line  75)
* CompareAbsTo:                          MPIR.Net Integers.   (line 188)
* CompareAbsTo <1>:                      MPIR.Net Integers.   (line 189)
* CompareAbsTo <2>:                      MPIR.Net Integers.   (line 190)
* CompareTo:                             MPIR.Net Integers.   (line 171)
* CompareTo <1>:                         MPIR.Net Integers.   (line 176)
* CompareTo <2>:                         MPIR.Net Rationals.  (line 172)
* CompareTo <3>:                         MPIR.Net Rationals.  (line 177)
* CompareTo <4>:                         MPIR.Net Rationals.  (line 185)
* CompareTo <5>:                         MPIR.Net Rationals.  (line 186)
* CompareTo <6>:                         MPIR.Net Floats.     (line 173)
* CompareTo <7>:                         MPIR.Net Floats.     (line 178)
* ComplementBit:                         MPIR.Net Integers.   (line 210)
* Copy:                                  MPIR.Net Random Numbers.
                                                              (line  23)
* Default:                               MPIR.Net Random Numbers.
                                                              (line  13)
* DefaultPrecision:                      MPIR.Net Floats.     (line  30)
* Denominator:                           MPIR.Net Rationals.  (line  78)
* DivideExactly:                         MPIR.Net Integers.   (line 230)
* DivideExactly <1>:                     MPIR.Net Integers.   (line 231)
* Equals:                                MPIR.Net Integers.   (line 172)
* Equals <1>:                            MPIR.Net Integers.   (line 177)
* Equals <2>:                            MPIR.Net Rationals.  (line 173)
* Equals <3>:                            MPIR.Net Rationals.  (line 178)
* Equals <4>:                            MPIR.Net Rationals.  (line 183)
* Equals <5>:                            MPIR.Net Rationals.  (line 184)
* Equals <6>:                            MPIR.Net Floats.     (line 174)
* Equals <7>:                            MPIR.Net Floats.     (line 179)
* Equals <8>:                            MPIR.Net Floats.     (line 192)
* Export<T>:                             MPIR.Net Integers.   (line 274)
* Export<T> <1>:                         MPIR.Net Integers.   (line 276)
* Factorial:                             MPIR.Net Integers.   (line 293)
* Factorial <1>:                         MPIR.Net Integers.   (line 294)
* Fibonacci:                             MPIR.Net Integers.   (line 303)
* FindBit:                               MPIR.Net Integers.   (line 221)
* FitsInt:                               MPIR.Net Integers.   (line  69)
* FitsInt <1>:                           MPIR.Net Floats.     (line  99)
* FitsLong:                              MPIR.Net Integers.   (line  67)
* FitsLong <1>:                          MPIR.Net Floats.     (line  97)
* FitsShort:                             MPIR.Net Integers.   (line  71)
* FitsShort <1>:                         MPIR.Net Floats.     (line 101)
* FitsUint:                              MPIR.Net Integers.   (line  68)
* FitsUint <1>:                          MPIR.Net Floats.     (line  98)
* FitsUlong:                             MPIR.Net Integers.   (line  66)
* FitsUlong <1>:                         MPIR.Net Floats.     (line  96)
* FitsUshort:                            MPIR.Net Integers.   (line  70)
* FitsUshort <1>:                        MPIR.Net Floats.     (line 100)
* floor:                                 C++ Interface Floats.
                                                              (line  85)
* Floor:                                 MPIR.Net Floats.     (line 202)
* Gcd:                                   MPIR.Net Integers.   (line 334)
* Gcd <1>:                               MPIR.Net Integers.   (line 338)
* GetBit:                                MPIR.Net Integers.   (line 208)
* GetFloat:                              MPIR.Net Random Numbers.
                                                              (line  49)
* GetFloatBits:                          MPIR.Net Random Numbers.
                                                              (line  54)
* GetFloatChunky:                        MPIR.Net Random Numbers.
                                                              (line  59)
* GetFloatLimbsChunky:                   MPIR.Net Random Numbers.
                                                              (line  65)
* GetHashCode:                           MPIR.Net Integers.   (line 182)
* GetHashCode <1>:                       MPIR.Net Rationals.  (line 189)
* GetHashCode <2>:                       MPIR.Net Floats.     (line 186)
* GetInt:                                MPIR.Net Random Numbers.
                                                              (line  44)
* GetIntBits:                            MPIR.Net Random Numbers.
                                                              (line  39)
* GetIntBitsChunky:                      MPIR.Net Random Numbers.
                                                              (line  40)
* GetLimb:                               MPIR.Net Integers.   (line  63)
* GetLimb <1>:                           MPIR.Net Random Numbers.
                                                              (line  35)
* GetLimbBits:                           MPIR.Net Random Numbers.
                                                              (line  31)
* gmp_asprintf:                          Formatted Output Functions.
                                                              (line  63)
* gmp_fprintf:                           Formatted Output Functions.
                                                              (line  28)
* gmp_fscanf:                            Formatted Input Functions.
                                                              (line  24)
* GMP_LIMB_BITS:                         Low-level Functions. (line 544)
* GMP_NAIL_BITS:                         Low-level Functions. (line 542)
* GMP_NAIL_MASK:                         Low-level Functions. (line 552)
* GMP_NUMB_BITS:                         Low-level Functions. (line 543)
* GMP_NUMB_MASK:                         Low-level Functions. (line 553)
* GMP_NUMB_MAX:                          Low-level Functions. (line 561)
* gmp_obstack_printf:                    Formatted Output Functions.
                                                              (line  75)
* gmp_obstack_vprintf:                   Formatted Output Functions.
                                                              (line  77)
* gmp_printf:                            Formatted Output Functions.
                                                              (line  23)
* gmp_randclass:                         C++ Interface Random Numbers.
                                                              (line   6)
* gmp_randclass::get_f:                  C++ Interface Random Numbers.
                                                              (line  38)
* gmp_randclass::get_f <1>:              C++ Interface Random Numbers.
                                                              (line  39)
* gmp_randclass::get_z_bits:             C++ Interface Random Numbers.
                                                              (line  31)
* gmp_randclass::get_z_bits <1>:         C++ Interface Random Numbers.
                                                              (line  32)
* gmp_randclass::get_z_range:            C++ Interface Random Numbers.
                                                              (line  35)
* gmp_randclass::gmp_randclass:          C++ Interface Random Numbers.
                                                              (line  11)
* gmp_randclass::seed:                   C++ Interface Random Numbers.
                                                              (line  26)
* gmp_randclass::seed <1>:               C++ Interface Random Numbers.
                                                              (line  27)
* gmp_randclear:                         Random State Initialization.
                                                              (line  46)
* gmp_randinit_default:                  Random State Initialization.
                                                              (line   6)
* gmp_randinit_lc_2exp:                  Random State Initialization.
                                                              (line  16)
* gmp_randinit_lc_2exp_size:             Random State Initialization.
                                                              (line  31)
* gmp_randinit_mt:                       Random State Initialization.
                                                              (line  12)
* gmp_randinit_set:                      Random State Initialization.
                                                              (line  42)
* gmp_randseed:                          Random State Seeding.
                                                              (line   6)
* gmp_randseed_ui:                       Random State Seeding.
                                                              (line   7)
* 'gmp_randstate_t':                     Nomenclature and Types.
                                                              (line  45)
* gmp_scanf:                             Formatted Input Functions.
                                                              (line  20)
* gmp_snprintf:                          Formatted Output Functions.
                                                              (line  44)
* gmp_sprintf:                           Formatted Output Functions.
                                                              (line  33)
* gmp_sscanf:                            Formatted Input Functions.
                                                              (line  28)
* gmp_urandomb_ui:                       Random State Miscellaneous.
                                                              (line   6)
* gmp_urandomm_ui:                       Random State Miscellaneous.
                                                              (line  11)
* gmp_vasprintf:                         Formatted Output Functions.
                                                              (line  64)
* gmp_version:                           Useful Macros and Constants.
                                                              (line  25)
* GMP_VERSION:                           MPIR.Net Settings.   (line  25)
* gmp_vfprintf:                          Formatted Output Functions.
                                                              (line  29)
* gmp_vfscanf:                           Formatted Input Functions.
                                                              (line  25)
* gmp_vprintf:                           Formatted Output Functions.
                                                              (line  24)
* gmp_vscanf:                            Formatted Input Functions.
                                                              (line  21)
* gmp_vsnprintf:                         Formatted Output Functions.
                                                              (line  46)
* gmp_vsprintf:                          Formatted Output Functions.
                                                              (line  34)
* gmp_vsscanf:                           Formatted Input Functions.
                                                              (line  29)
* HammingDistance:                       MPIR.Net Integers.   (line 217)
* HugeFloat:                             MPIR.Net Feature Overview.
                                                              (line  10)
* HugeFloat <1>:                         MPIR.Net Floats.     (line   6)
* HugeFloat <2>:                         MPIR.Net Floats.     (line  46)
* HugeFloat <3>:                         MPIR.Net Floats.     (line  47)
* HugeFloat <4>:                         MPIR.Net Floats.     (line  48)
* HugeFloat <5>:                         MPIR.Net Floats.     (line  49)
* HugeFloat <6>:                         MPIR.Net Floats.     (line  56)
* HugeFloat <7>:                         MPIR.Net Floats.     (line  57)
* HugeFloat <8>:                         MPIR.Net Floats.     (line  58)
* HugeFloat <9>:                         MPIR.Net Floats.     (line  63)
* HugeFloat <10>:                        MPIR.Net Floats.     (line  64)
* HugeFloat <11>:                        MPIR.Net Floats.     (line  65)
* HugeInt:                               MPIR.Net Feature Overview.
                                                              (line   8)
* HugeInt <1>:                           MPIR.Net Integers.   (line   6)
* HugeInt <2>:                           MPIR.Net Integers.   (line  30)
* HugeInt <3>:                           MPIR.Net Integers.   (line  31)
* HugeInt <4>:                           MPIR.Net Integers.   (line  32)
* HugeInt <5>:                           MPIR.Net Integers.   (line  33)
* HugeInt <6>:                           MPIR.Net Integers.   (line  40)
* HugeInt <7>:                           MPIR.Net Integers.   (line  41)
* HugeInt <8>:                           MPIR.Net Integers.   (line  46)
* HugeRational:                          MPIR.Net Feature Overview.
                                                              (line   9)
* HugeRational <1>:                      MPIR.Net Rationals.  (line   6)
* HugeRational <2>:                      MPIR.Net Rationals.  (line  29)
* HugeRational <3>:                      MPIR.Net Rationals.  (line  30)
* HugeRational <4>:                      MPIR.Net Rationals.  (line  32)
* HugeRational <5>:                      MPIR.Net Rationals.  (line  34)
* HugeRational <6>:                      MPIR.Net Rationals.  (line  36)
* HugeRational <7>:                      MPIR.Net Rationals.  (line  43)
* HugeRational <8>:                      MPIR.Net Rationals.  (line  44)
* HugeRational <9>:                      MPIR.Net Rationals.  (line  54)
* HugeRational <10>:                     MPIR.Net Rationals.  (line  55)
* HugeRational <11>:                     MPIR.Net Rationals.  (line  56)
* hypot:                                 C++ Interface Floats.
                                                              (line  86)
* Import<T>:                             MPIR.Net Integers.   (line 272)
* Invert:                                MPIR.Net Integers.   (line 349)
* Invert <1>:                            MPIR.Net Rationals.  (line 203)
* IsCongruentTo:                         MPIR.Net Integers.   (line 246)
* IsCongruentTo <1>:                     MPIR.Net Integers.   (line 248)
* IsCongruentToModPowerOf2:              MPIR.Net Integers.   (line 249)
* IsDivisibleBy:                         MPIR.Net Integers.   (line 243)
* IsDivisibleBy <1>:                     MPIR.Net Integers.   (line 244)
* IsDivisibleByPowerOf2:                 MPIR.Net Integers.   (line 245)
* IsInteger:                             MPIR.Net Floats.     (line 105)
* IsLikelyPrime:                         MPIR.Net Integers.   (line 283)
* IsPerfectPower:                        MPIR.Net Integers.   (line 251)
* IsPerfectSquare:                       MPIR.Net Integers.   (line 252)
* IsProbablePrime:                       MPIR.Net Integers.   (line 281)
* Jacobi:                                MPIR.Net Integers.   (line 284)
* Kronecker:                             MPIR.Net Integers.   (line 286)
* Kronecker <1>:                         MPIR.Net Integers.   (line 287)
* Kronecker <2>:                         MPIR.Net Integers.   (line 288)
* Kronecker <3>:                         MPIR.Net Integers.   (line 289)
* Kronecker <4>:                         MPIR.Net Integers.   (line 290)
* Lcm:                                   MPIR.Net Integers.   (line 345)
* Lcm <1>:                               MPIR.Net Integers.   (line 346)
* Legendre:                              MPIR.Net Integers.   (line 285)
* LinearCongruential:                    MPIR.Net Random Numbers.
                                                              (line  15)
* LinearCongruential <1>:                MPIR.Net Random Numbers.
                                                              (line  17)
* long:                                  MPIR on Windows x64. (line  27)
* long <1>:                              MPIR on Windows x64. (line  29)
* Lucas:                                 MPIR.Net Integers.   (line 305)
* MersenneTwister:                       MPIR.Net Random Numbers.
                                                              (line  14)
* Mod:                                   MPIR.Net Integers.   (line 149)
* Mod <1>:                               MPIR.Net Integers.   (line 150)
* mpf_abs:                               Float Arithmetic.    (line  39)
* mpf_add:                               Float Arithmetic.    (line   6)
* mpf_add_ui:                            Float Arithmetic.    (line   7)
* mpf_ceil:                              Miscellaneous Float Functions.
                                                              (line   6)
* mpf_class:                             C++ Interface General.
                                                              (line  19)
* mpf_class::fits_sint_p:                C++ Interface Floats.
                                                              (line  77)
* mpf_class::fits_slong_p:               C++ Interface Floats.
                                                              (line  78)
* mpf_class::fits_sshort_p:              C++ Interface Floats.
                                                              (line  79)
* mpf_class::fits_uint_p:                C++ Interface Floats.
                                                              (line  81)
* mpf_class::fits_ulong_p:               C++ Interface Floats.
                                                              (line  82)
* mpf_class::fits_ushort_p:              C++ Interface Floats.
                                                              (line  83)
* mpf_class::get_d:                      C++ Interface Floats.
                                                              (line  88)
* mpf_class::get_mpf_t:                  C++ Interface General.
                                                              (line  65)
* mpf_class::get_prec:                   C++ Interface Floats.
                                                              (line 109)
* mpf_class::get_si:                     C++ Interface Floats.
                                                              (line  89)
* mpf_class::get_str:                    C++ Interface Floats.
                                                              (line  90)
* mpf_class::get_ui:                     C++ Interface Floats.
                                                              (line  92)
* mpf_class::mpf_class:                  C++ Interface Floats.
                                                              (line  11)
* mpf_class::mpf_class <1>:              C++ Interface Floats.
                                                              (line  12)
* mpf_class::mpf_class <2>:              C++ Interface Floats.
                                                              (line  31)
* mpf_class::mpf_class <3>:              C++ Interface Floats.
                                                              (line  32)
* mpf_class::mpf_class <4>:              C++ Interface Floats.
                                                              (line  34)
* mpf_class::mpf_class <5>:              C++ Interface Floats.
                                                              (line  35)
* mpf_class::operator=:                  C++ Interface Floats.
                                                              (line  49)
* mpf_class::set_prec:                   C++ Interface Floats.
                                                              (line 110)
* mpf_class::set_prec_raw:               C++ Interface Floats.
                                                              (line 111)
* mpf_class::set_str:                    C++ Interface Floats.
                                                              (line  94)
* mpf_class::set_str <1>:                C++ Interface Floats.
                                                              (line  95)
* mpf_class::swap:                       C++ Interface Floats.
                                                              (line  98)
* mpf_clear:                             Initializing Floats. (line  36)
* mpf_clears:                            Initializing Floats. (line  40)
* mpf_cmp:                               Float Comparison.    (line   6)
* mpf_cmp_d:                             Float Comparison.    (line   7)
* mpf_cmp_si:                            Float Comparison.    (line   9)
* mpf_cmp_ui:                            Float Comparison.    (line   8)
* mpf_div:                               Float Arithmetic.    (line  24)
* mpf_div_2exp:                          Float Arithmetic.    (line  45)
* mpf_div_ui:                            Float Arithmetic.    (line  26)
* mpf_eq:                                Float Comparison.    (line  16)
* mpf_fits_sint_p:                       Miscellaneous Float Functions.
                                                              (line  19)
* mpf_fits_slong_p:                      Miscellaneous Float Functions.
                                                              (line  17)
* mpf_fits_sshort_p:                     Miscellaneous Float Functions.
                                                              (line  21)
* mpf_fits_uint_p:                       Miscellaneous Float Functions.
                                                              (line  18)
* mpf_fits_ulong_p:                      Miscellaneous Float Functions.
                                                              (line  16)
* mpf_fits_ushort_p:                     Miscellaneous Float Functions.
                                                              (line  20)
* mpf_floor:                             Miscellaneous Float Functions.
                                                              (line   7)
* mpf_get_d:                             Converting Floats.   (line   6)
* mpf_get_default_prec:                  Initializing Floats. (line  11)
* mpf_get_d_2exp:                        Converting Floats.   (line  15)
* mpf_get_prec:                          Initializing Floats. (line  61)
* mpf_get_si:                            Converting Floats.   (line  26)
* mpf_get_str:                           Converting Floats.   (line  35)
* mpf_get_ui:                            Converting Floats.   (line  27)
* mpf_init:                              Initializing Floats. (line  18)
* mpf_init2:                             Initializing Floats. (line  25)
* mpf_inits:                             Initializing Floats. (line  30)
* mpf_init_set:                          Simultaneous Float Init & Assign.
                                                              (line  15)
* mpf_init_set_d:                        Simultaneous Float Init & Assign.
                                                              (line  18)
* mpf_init_set_si:                       Simultaneous Float Init & Assign.
                                                              (line  17)
* mpf_init_set_str:                      Simultaneous Float Init & Assign.
                                                              (line  24)
* mpf_init_set_ui:                       Simultaneous Float Init & Assign.
                                                              (line  16)
* mpf_inp_str:                           I/O of Floats.       (line  35)
* mpf_integer_p:                         Miscellaneous Float Functions.
                                                              (line  13)
* mpf_mul:                               Float Arithmetic.    (line  15)
* mpf_mul_2exp:                          Float Arithmetic.    (line  42)
* mpf_mul_ui:                            Float Arithmetic.    (line  16)
* mpf_neg:                               Float Arithmetic.    (line  36)
* mpf_out_str:                           I/O of Floats.       (line  15)
* mpf_pow_ui:                            Float Arithmetic.    (line  33)
* mpf_random2:                           Miscellaneous Float Functions.
                                                              (line  47)
* mpf_reldiff:                           Float Comparison.    (line  23)
* mpf_rrandomb:                          Miscellaneous Float Functions.
                                                              (line  34)
* mpf_set:                               Assigning Floats.    (line   9)
* mpf_set_d:                             Assigning Floats.    (line  12)
* mpf_set_default_prec:                  Initializing Floats. (line   6)
* mpf_set_prec:                          Initializing Floats. (line  64)
* mpf_set_prec_raw:                      Initializing Floats. (line  71)
* mpf_set_q:                             Assigning Floats.    (line  14)
* mpf_set_si:                            Assigning Floats.    (line  11)
* mpf_set_str:                           Assigning Floats.    (line  17)
* mpf_set_ui:                            Assigning Floats.    (line  10)
* mpf_set_z:                             Assigning Floats.    (line  13)
* mpf_sgn:                               Float Comparison.    (line  27)
* mpf_sqrt:                              Float Arithmetic.    (line  29)
* mpf_sqrt_ui:                           Float Arithmetic.    (line  30)
* mpf_sub:                               Float Arithmetic.    (line  10)
* mpf_sub_ui:                            Float Arithmetic.    (line  12)
* mpf_swap:                              Assigning Floats.    (line  50)
* 'mpf_t':                               Nomenclature and Types.
                                                              (line  21)
* mpf_trunc:                             Miscellaneous Float Functions.
                                                              (line   8)
* mpf_ui_div:                            Float Arithmetic.    (line  25)
* mpf_ui_sub:                            Float Arithmetic.    (line  11)
* mpf_urandomb:                          Miscellaneous Float Functions.
                                                              (line  25)
* MpirRandom:                            MPIR.Net Feature Overview.
                                                              (line  11)
* MpirRandom <1>:                        MPIR.Net Random Numbers.
                                                              (line   6)
* MpirSettings:                          MPIR.Net Settings.   (line   6)
* mpir_version:                          Useful Macros and Constants.
                                                              (line  34)
* MPIR_VERSION:                          MPIR.Net Settings.   (line  22)
* mpn_add:                               Low-level Functions. (line  68)
* mpn_addmul_1:                          Low-level Functions. (line 129)
* mpn_add_1:                             Low-level Functions. (line  63)
* mpn_add_n:                             Low-level Functions. (line  53)
* mpn_andn_n:                            Low-level Functions. (line 468)
* mpn_and_n:                             Low-level Functions. (line 453)
* mpn_cmp:                               Low-level Functions. (line 278)
* mpn_com:                               Low-level Functions. (line 493)
* mpn_copyd:                             Low-level Functions. (line 502)
* mpn_copyi:                             Low-level Functions. (line 498)
* mpn_divexact_by3:                      Low-level Functions. (line 223)
* mpn_divexact_by3c:                     Low-level Functions. (line 225)
* mpn_divmod_1:                          Low-level Functions. (line 207)
* mpn_divrem:                            Low-level Functions. (line 180)
* mpn_divrem_1:                          Low-level Functions. (line 205)
* mpn_gcd:                               Low-level Functions. (line 283)
* mpn_gcdext:                            Low-level Functions. (line 299)
* mpn_gcd_1:                             Low-level Functions. (line 294)
* mpn_get_str:                           Low-level Functions. (line 342)
* mpn_hamdist:                           Low-level Functions. (line 443)
* mpn_iorn_n:                            Low-level Functions. (line 473)
* mpn_ior_n:                             Low-level Functions. (line 458)
* mpn_lshift:                            Low-level Functions. (line 254)
* mpn_mod_1:                             Low-level Functions. (line 249)
* mpn_mul:                               Low-level Functions. (line 151)
* mpn_mul_1:                             Low-level Functions. (line 114)
* mpn_mul_n:                             Low-level Functions. (line 102)
* mpn_nand_n:                            Low-level Functions. (line 478)
* mpn_neg:                               Low-level Functions. (line  97)
* mpn_nior_n:                            Low-level Functions. (line 483)
* mpn_perfect_square_p:                  Low-level Functions. (line 449)
* mpn_popcount:                          Low-level Functions. (line 439)
* mpn_random:                            Low-level Functions. (line 392)
* mpn_random2:                           Low-level Functions. (line 393)
* mpn_randomb:                           Low-level Functions. (line 421)
* mpn_rrandom:                           Low-level Functions. (line 429)
* mpn_rshift:                            Low-level Functions. (line 266)
* mpn_scan0:                             Low-level Functions. (line 376)
* mpn_scan1:                             Low-level Functions. (line 384)
* mpn_set_str:                           Low-level Functions. (line 357)
* mpn_sqr:                               Low-level Functions. (line 162)
* mpn_sqrtrem:                           Low-level Functions. (line 324)
* mpn_sub:                               Low-level Functions. (line  89)
* mpn_submul_1:                          Low-level Functions. (line 140)
* mpn_sub_1:                             Low-level Functions. (line  84)
* mpn_sub_n:                             Low-level Functions. (line  75)
* mpn_tdiv_qr:                           Low-level Functions. (line 170)
* mpn_urandomb:                          Low-level Functions. (line 405)
* mpn_urandomm:                          Low-level Functions. (line 413)
* mpn_xnor_n:                            Low-level Functions. (line 488)
* mpn_xor_n:                             Low-level Functions. (line 463)
* mpn_zero:                              Low-level Functions. (line 506)
* mpq_abs:                               Rational Arithmetic. (line  30)
* mpq_add:                               Rational Arithmetic. (line   6)
* mpq_canonicalize:                      Rational Number Functions.
                                                              (line  21)
* mpq_class:                             C++ Interface General.
                                                              (line  18)
* mpq_class::canonicalize:               C++ Interface Rationals.
                                                              (line  40)
* mpq_class::get_d:                      C++ Interface Rationals.
                                                              (line  50)
* mpq_class::get_den:                    C++ Interface Rationals.
                                                              (line  65)
* mpq_class::get_den_mpz_t:              C++ Interface Rationals.
                                                              (line  75)
* mpq_class::get_mpq_t:                  C++ Interface General.
                                                              (line  64)
* mpq_class::get_num:                    C++ Interface Rationals.
                                                              (line  64)
* mpq_class::get_num_mpz_t:              C++ Interface Rationals.
                                                              (line  74)
* mpq_class::get_str:                    C++ Interface Rationals.
                                                              (line  51)
* mpq_class::mpq_class:                  C++ Interface Rationals.
                                                              (line   9)
* mpq_class::mpq_class <1>:              C++ Interface Rationals.
                                                              (line  10)
* mpq_class::mpq_class <2>:              C++ Interface Rationals.
                                                              (line  20)
* mpq_class::mpq_class <3>:              C++ Interface Rationals.
                                                              (line  25)
* mpq_class::mpq_class <4>:              C++ Interface Rationals.
                                                              (line  26)
* mpq_class::mpq_class <5>:              C++ Interface Rationals.
                                                              (line  27)
* mpq_class::mpq_class <6>:              C++ Interface Rationals.
                                                              (line  28)
* mpq_class::set_str:                    C++ Interface Rationals.
                                                              (line  53)
* mpq_class::set_str <1>:                C++ Interface Rationals.
                                                              (line  54)
* mpq_class::swap:                       C++ Interface Rationals.
                                                              (line  56)
* mpq_clear:                             Initializing Rationals.
                                                              (line  15)
* mpq_clears:                            Initializing Rationals.
                                                              (line  19)
* mpq_cmp:                               Comparing Rationals. (line   6)
* mpq_cmp_si:                            Comparing Rationals. (line  15)
* mpq_cmp_ui:                            Comparing Rationals. (line  14)
* mpq_cmp_z:                             Comparing Rationals. (line   7)
* mpq_denref:                            Applying Integer Functions.
                                                              (line  16)
* mpq_div:                               Rational Arithmetic. (line  20)
* mpq_div_2exp:                          Rational Arithmetic. (line  24)
* mpq_equal:                             Comparing Rationals. (line  31)
* mpq_get_d:                             Rational Conversions.
                                                              (line   6)
* mpq_get_den:                           Applying Integer Functions.
                                                              (line  22)
* mpq_get_num:                           Applying Integer Functions.
                                                              (line  21)
* mpq_get_str:                           Rational Conversions.
                                                              (line  21)
* mpq_init:                              Initializing Rationals.
                                                              (line   6)
* mpq_inits:                             Initializing Rationals.
                                                              (line  11)
* mpq_inp_str:                           I/O of Rationals.    (line  22)
* mpq_inv:                               Rational Arithmetic. (line  33)
* mpq_mul:                               Rational Arithmetic. (line  13)
* mpq_mul_2exp:                          Rational Arithmetic. (line  17)
* mpq_neg:                               Rational Arithmetic. (line  27)
* mpq_numref:                            Applying Integer Functions.
                                                              (line  15)
* mpq_out_str:                           I/O of Rationals.    (line  14)
* mpq_set:                               Initializing Rationals.
                                                              (line  23)
* mpq_set_d:                             Rational Conversions.
                                                              (line  16)
* mpq_set_den:                           Applying Integer Functions.
                                                              (line  24)
* mpq_set_f:                             Rational Conversions.
                                                              (line  17)
* mpq_set_num:                           Applying Integer Functions.
                                                              (line  23)
* mpq_set_si:                            Initializing Rationals.
                                                              (line  28)
* mpq_set_str:                           Initializing Rationals.
                                                              (line  33)
* mpq_set_ui:                            Initializing Rationals.
                                                              (line  27)
* mpq_set_z:                             Initializing Rationals.
                                                              (line  24)
* mpq_sgn:                               Comparing Rationals. (line  25)
* mpq_sub:                               Rational Arithmetic. (line   9)
* mpq_swap:                              Initializing Rationals.
                                                              (line  52)
* 'mpq_t':                               Nomenclature and Types.
                                                              (line  16)
* mpz_2fac_ui:                           Number Theoretic Functions.
                                                              (line 160)
* mpz_abs:                               Integer Arithmetic.  (line  35)
* mpz_add:                               Integer Arithmetic.  (line   6)
* mpz_addmul:                            Integer Arithmetic.  (line  20)
* mpz_addmul_ui:                         Integer Arithmetic.  (line  21)
* mpz_add_ui:                            Integer Arithmetic.  (line   7)
* mpz_and:                               Integer Logic and Bit Fiddling.
                                                              (line  10)
* mpz_array_init:                        Integer Special Functions.
                                                              (line   9)
* mpz_bin_ui:                            Number Theoretic Functions.
                                                              (line 171)
* mpz_bin_uiui:                          Number Theoretic Functions.
                                                              (line 172)
* mpz_cdiv_q:                            Integer Division.    (line  12)
* mpz_cdiv_qr:                           Integer Division.    (line  14)
* mpz_cdiv_qr_ui:                        Integer Division.    (line  18)
* mpz_cdiv_q_2exp:                       Integer Division.    (line  22)
* mpz_cdiv_q_ui:                         Integer Division.    (line  16)
* mpz_cdiv_r:                            Integer Division.    (line  13)
* mpz_cdiv_r_2exp:                       Integer Division.    (line  23)
* mpz_cdiv_r_ui:                         Integer Division.    (line  17)
* mpz_cdiv_ui:                           Integer Division.    (line  20)
* mpz_class:                             C++ Interface General.
                                                              (line  17)
* mpz_class::fits_sint_p:                C++ Interface Integers.
                                                              (line  48)
* mpz_class::fits_slong_p:               C++ Interface Integers.
                                                              (line  49)
* mpz_class::fits_sshort_p:              C++ Interface Integers.
                                                              (line  50)
* mpz_class::fits_uint_p:                C++ Interface Integers.
                                                              (line  52)
* mpz_class::fits_ulong_p:               C++ Interface Integers.
                                                              (line  53)
* mpz_class::fits_ushort_p:              C++ Interface Integers.
                                                              (line  54)
* mpz_class::get_d:                      C++ Interface Integers.
                                                              (line  56)
* mpz_class::get_mpz_t:                  C++ Interface General.
                                                              (line  63)
* mpz_class::get_si:                     C++ Interface Integers.
                                                              (line  57)
* mpz_class::get_str:                    C++ Interface Integers.
                                                              (line  58)
* mpz_class::get_ui:                     C++ Interface Integers.
                                                              (line  59)
* mpz_class::mpz_class:                  C++ Interface Integers.
                                                              (line   6)
* mpz_class::mpz_class <1>:              C++ Interface Integers.
                                                              (line  12)
* mpz_class::mpz_class <2>:              C++ Interface Integers.
                                                              (line  17)
* mpz_class::mpz_class <3>:              C++ Interface Integers.
                                                              (line  18)
* mpz_class::mpz_class <4>:              C++ Interface Integers.
                                                              (line  19)
* mpz_class::mpz_class <5>:              C++ Interface Integers.
                                                              (line  20)
* mpz_class::set_str:                    C++ Interface Integers.
                                                              (line  61)
* mpz_class::set_str <1>:                C++ Interface Integers.
                                                              (line  62)
* mpz_class::swap:                       C++ Interface Integers.
                                                              (line  65)
* mpz_clear:                             Initializing Integers.
                                                              (line  40)
* mpz_clears:                            Initializing Integers.
                                                              (line  44)
* mpz_clrbit:                            Integer Logic and Bit Fiddling.
                                                              (line  52)
* mpz_cmp:                               Integer Comparisons. (line   6)
* mpz_cmpabs:                            Integer Comparisons. (line  17)
* mpz_cmpabs_d:                          Integer Comparisons. (line  18)
* mpz_cmpabs_ui:                         Integer Comparisons. (line  19)
* mpz_cmp_d:                             Integer Comparisons. (line   7)
* mpz_cmp_si:                            Integer Comparisons. (line   8)
* mpz_cmp_ui:                            Integer Comparisons. (line   9)
* mpz_com:                               Integer Logic and Bit Fiddling.
                                                              (line  19)
* mpz_combit:                            Integer Logic and Bit Fiddling.
                                                              (line  55)
* mpz_congruent_2exp_p:                  Integer Division.    (line 119)
* mpz_congruent_p:                       Integer Division.    (line 117)
* mpz_congruent_ui_p:                    Integer Division.    (line 118)
* mpz_divexact:                          Integer Division.    (line  97)
* mpz_divexact_ui:                       Integer Division.    (line  98)
* mpz_divisible_2exp_p:                  Integer Division.    (line 108)
* mpz_divisible_p:                       Integer Division.    (line 106)
* mpz_divisible_ui_p:                    Integer Division.    (line 107)
* mpz_even_p:                            Miscellaneous Integer Functions.
                                                              (line  17)
* mpz_export:                            Integer Import and Export.
                                                              (line  43)
* mpz_fac_ui:                            Number Theoretic Functions.
                                                              (line 159)
* mpz_fdiv_q:                            Integer Division.    (line  25)
* mpz_fdiv_qr:                           Integer Division.    (line  27)
* mpz_fdiv_qr_ui:                        Integer Division.    (line  31)
* mpz_fdiv_q_2exp:                       Integer Division.    (line  35)
* mpz_fdiv_q_ui:                         Integer Division.    (line  29)
* mpz_fdiv_r:                            Integer Division.    (line  26)
* mpz_fdiv_r_2exp:                       Integer Division.    (line  36)
* mpz_fdiv_r_ui:                         Integer Division.    (line  30)
* mpz_fdiv_ui:                           Integer Division.    (line  33)
* mpz_fib2_ui:                           Number Theoretic Functions.
                                                              (line 179)
* mpz_fib_ui:                            Number Theoretic Functions.
                                                              (line 178)
* mpz_fits_sint_p:                       Miscellaneous Integer Functions.
                                                              (line   9)
* mpz_fits_slong_p:                      Miscellaneous Integer Functions.
                                                              (line   7)
* mpz_fits_sshort_p:                     Miscellaneous Integer Functions.
                                                              (line  11)
* mpz_fits_uint_p:                       Miscellaneous Integer Functions.
                                                              (line   8)
* mpz_fits_ulong_p:                      Miscellaneous Integer Functions.
                                                              (line   6)
* mpz_fits_ushort_p:                     Miscellaneous Integer Functions.
                                                              (line  10)
* mpz_gcd:                               Number Theoretic Functions.
                                                              (line  84)
* mpz_gcdext:                            Number Theoretic Functions.
                                                              (line  97)
* mpz_gcd_ui:                            Number Theoretic Functions.
                                                              (line  88)
* mpz_getlimbn:                          Integer Special Functions.
                                                              (line  62)
* mpz_get_d:                             Converting Integers. (line  41)
* mpz_get_d_2exp:                        Converting Integers. (line  49)
* mpz_get_si:                            MPIR on Windows x64. (line  50)
* mpz_get_si <1>:                        Converting Integers. (line  17)
* mpz_get_str:                           Converting Integers. (line  60)
* mpz_get_sx:                            Converting Integers. (line  33)
* mpz_get_ui:                            MPIR on Windows x64. (line  48)
* mpz_get_ui <1>:                        Converting Integers. (line  10)
* mpz_get_ux:                            Converting Integers. (line  25)
* mpz_hamdist:                           Integer Logic and Bit Fiddling.
                                                              (line  28)
* mpz_import:                            Integer Import and Export.
                                                              (line   9)
* mpz_init:                              Initializing Integers.
                                                              (line  25)
* mpz_init2:                             Initializing Integers.
                                                              (line  32)
* mpz_inits:                             Initializing Integers.
                                                              (line  28)
* mpz_init_set:                          Simultaneous Integer Init & Assign.
                                                              (line  26)
* mpz_init_set_d:                        Simultaneous Integer Init & Assign.
                                                              (line  31)
* mpz_init_set_si:                       Simultaneous Integer Init & Assign.
                                                              (line  28)
* mpz_init_set_str:                      Simultaneous Integer Init & Assign.
                                                              (line  36)
* mpz_init_set_sx:                       Simultaneous Integer Init & Assign.
                                                              (line  30)
* mpz_init_set_ui:                       Simultaneous Integer Init & Assign.
                                                              (line  27)
* mpz_init_set_ux:                       Simultaneous Integer Init & Assign.
                                                              (line  29)
* mpz_inp_raw:                           I/O of Integers.     (line  58)
* mpz_inp_str:                           I/O of Integers.     (line  27)
* mpz_invert:                            Number Theoretic Functions.
                                                              (line 123)
* mpz_ior:                               Integer Logic and Bit Fiddling.
                                                              (line  13)
* mpz_jacobi:                            Number Theoretic Functions.
                                                              (line 129)
* mpz_kronecker:                         Number Theoretic Functions.
                                                              (line 137)
* mpz_kronecker_si:                      Number Theoretic Functions.
                                                              (line 138)
* mpz_kronecker_ui:                      Number Theoretic Functions.
                                                              (line 139)
* mpz_lcm:                               Number Theoretic Functions.
                                                              (line 117)
* mpz_lcm_ui:                            Number Theoretic Functions.
                                                              (line 118)
* mpz_legendre:                          Number Theoretic Functions.
                                                              (line 132)
* mpz_likely_prime_p:                    Number Theoretic Functions.
                                                              (line  24)
* mpz_limbs_finish:                      Integer Special Functions.
                                                              (line  87)
* mpz_limbs_modify:                      Integer Special Functions.
                                                              (line  80)
* mpz_limbs_read:                        Integer Special Functions.
                                                              (line  74)
* mpz_limbs_write:                       Integer Special Functions.
                                                              (line  79)
* mpz_lucnum2_ui:                        Number Theoretic Functions.
                                                              (line 189)
* mpz_lucnum_ui:                         Number Theoretic Functions.
                                                              (line 188)
* mpz_mfac_uiui:                         Number Theoretic Functions.
                                                              (line 161)
* mpz_mod:                               Integer Division.    (line  88)
* mpz_mod_ui:                            Integer Division.    (line  89)
* mpz_mul:                               Integer Arithmetic.  (line  15)
* mpz_mul_2exp:                          Integer Arithmetic.  (line  28)
* mpz_mul_si:                            Integer Arithmetic.  (line  16)
* mpz_mul_ui:                            Integer Arithmetic.  (line  17)
* mpz_neg:                               Integer Arithmetic.  (line  32)
* mpz_nextprime:                         Number Theoretic Functions.
                                                              (line  59)
* mpz_next_prime_candidate:              Number Theoretic Functions.
                                                              (line  70)
* mpz_nthroot:                           Integer Roots.       (line  11)
* mpz_odd_p:                             Miscellaneous Integer Functions.
                                                              (line  16)
* mpz_out_raw:                           I/O of Integers.     (line  42)
* mpz_out_str:                           I/O of Integers.     (line  15)
* mpz_perfect_power_p:                   Integer Roots.       (line  29)
* mpz_perfect_square_p:                  Integer Roots.       (line  38)
* mpz_popcount:                          Integer Logic and Bit Fiddling.
                                                              (line  22)
* mpz_powm:                              Integer Exponentiation.
                                                              (line   6)
* mpz_powm_ui:                           Integer Exponentiation.
                                                              (line   8)
* mpz_pow_ui:                            Integer Exponentiation.
                                                              (line  17)
* mpz_primorial_ui:                      Number Theoretic Functions.
                                                              (line 167)
* mpz_probable_prime_p:                  Number Theoretic Functions.
                                                              (line   6)
* mpz_probab_prime_p:                    Number Theoretic Functions.
                                                              (line  40)
* mpz_realloc2:                          Initializing Integers.
                                                              (line  48)
* mpz_remove:                            Number Theoretic Functions.
                                                              (line 154)
* mpz_roinit_n:                          Integer Special Functions.
                                                              (line 107)
* MPZ_ROINIT_N:                          Integer Special Functions.
                                                              (line 123)
* mpz_root:                              Integer Roots.       (line   6)
* mpz_rootrem:                           Integer Roots.       (line  14)
* mpz_rrandomb:                          Integer Random Numbers.
                                                              (line  29)
* mpz_scan0:                             Integer Logic and Bit Fiddling.
                                                              (line  35)
* mpz_scan1:                             Integer Logic and Bit Fiddling.
                                                              (line  36)
* mpz_set:                               Assigning Integers.  (line   9)
* mpz_setbit:                            Integer Logic and Bit Fiddling.
                                                              (line  49)
* mpz_set_d:                             Assigning Integers.  (line  14)
* mpz_set_f:                             Assigning Integers.  (line  16)
* mpz_set_q:                             Assigning Integers.  (line  15)
* mpz_set_si:                            MPIR on Windows x64. (line  21)
* mpz_set_si <1>:                        MPIR on Windows x64. (line  46)
* mpz_set_si <2>:                        Assigning Integers.  (line  11)
* mpz_set_str:                           Assigning Integers.  (line  24)
* mpz_set_sx:                            Assigning Integers.  (line  13)
* mpz_set_ui:                            MPIR on Windows x64. (line  19)
* mpz_set_ui <1>:                        MPIR on Windows x64. (line  44)
* mpz_set_ui <2>:                        Assigning Integers.  (line  10)
* mpz_set_ux:                            Assigning Integers.  (line  12)
* mpz_sgn:                               Integer Comparisons. (line  27)
* mpz_size:                              Integer Special Functions.
                                                              (line  70)
* mpz_sizeinbase:                        Miscellaneous Integer Functions.
                                                              (line  22)
* mpz_si_kronecker:                      Number Theoretic Functions.
                                                              (line 140)
* mpz_sqrt:                              Integer Roots.       (line  19)
* mpz_sqrtrem:                           Integer Roots.       (line  22)
* mpz_sub:                               Integer Arithmetic.  (line  10)
* mpz_submul:                            Integer Arithmetic.  (line  24)
* mpz_submul_ui:                         Integer Arithmetic.  (line  25)
* mpz_sub_ui:                            Integer Arithmetic.  (line  11)
* mpz_swap:                              Assigning Integers.  (line  40)
* 'mpz_t':                               Nomenclature and Types.
                                                              (line   6)
* mpz_tdiv_q:                            Integer Division.    (line  38)
* mpz_tdiv_qr:                           Integer Division.    (line  40)
* mpz_tdiv_qr_ui:                        Integer Division.    (line  44)
* mpz_tdiv_q_2exp:                       Integer Division.    (line  48)
* mpz_tdiv_q_ui:                         Integer Division.    (line  42)
* mpz_tdiv_r:                            Integer Division.    (line  39)
* mpz_tdiv_r_2exp:                       Integer Division.    (line  49)
* mpz_tdiv_r_ui:                         Integer Division.    (line  43)
* mpz_tdiv_ui:                           Integer Division.    (line  46)
* mpz_tstbit:                            Integer Logic and Bit Fiddling.
                                                              (line  58)
* mpz_ui_kronecker:                      Number Theoretic Functions.
                                                              (line 141)
* mpz_ui_pow_ui:                         Integer Exponentiation.
                                                              (line  18)
* mpz_ui_sub:                            Integer Arithmetic.  (line  12)
* mpz_urandomb:                          Integer Random Numbers.
                                                              (line  12)
* mpz_urandomm:                          Integer Random Numbers.
                                                              (line  21)
* mpz_xor:                               Integer Logic and Bit Fiddling.
                                                              (line  16)
* 'mp_bitcnt_t':                         Nomenclature and Types.
                                                              (line  41)
* mp_bits_per_limb:                      Useful Macros and Constants.
                                                              (line   7)
* 'mp_exp_t':                            Nomenclature and Types.
                                                              (line  27)
* mp_get_memory_functions:               Custom Allocation.   (line  94)
* 'mp_limb_t':                           Nomenclature and Types.
                                                              (line  31)
* mp_set_memory_functions:               Custom Allocation.   (line  14)
* 'mp_size_t':                           Nomenclature and Types.
                                                              (line  37)
* NAIL_BITS_PER_LIMB:                    MPIR.Net Settings.   (line  15)
* NextPrimeCandidate:                    MPIR.Net Integers.   (line 330)
* Numerator:                             MPIR.Net Rationals.  (line  77)
* operator"":                            C++ Interface Integers.
                                                              (line  27)
* operator"" <1>:                        C++ Interface Rationals.
                                                              (line  35)
* operator"" <2>:                        C++ Interface Floats.
                                                              (line  45)
* operator%:                             C++ Interface Integers.
                                                              (line  32)
* operator/:                             C++ Interface Integers.
                                                              (line  31)
* operator<<:                            C++ Formatted Output.
                                                              (line  10)
* operator<< <1>:                        C++ Formatted Output.
                                                              (line  19)
* operator<< <2>:                        C++ Formatted Output.
                                                              (line  32)
* operator>>:                            C++ Formatted Input. (line  10)
* operator>> <1>:                        C++ Formatted Input. (line  13)
* operator>> <2>:                        C++ Formatted Input. (line  24)
* operator>> <3>:                        C++ Interface Rationals.
                                                              (line  84)
* PopCount:                              MPIR.Net Integers.   (line 214)
* Power:                                 MPIR.Net Integers.   (line 291)
* PowerMod:                              MPIR.Net Integers.   (line 236)
* PowerMod <1>:                          MPIR.Net Integers.   (line 238)
* Precision:                             MPIR.Net Floats.     (line  84)
* Primorial:                             MPIR.Net Integers.   (line 296)
* Read:                                  MPIR.Net Integers.   (line 261)
* Read <1>:                              MPIR.Net Integers.   (line 268)
* Read <2>:                              MPIR.Net Integers.   (line 269)
* Read <3>:                              MPIR.Net Rationals.  (line 207)
* Read <4>:                              MPIR.Net Rationals.  (line 214)
* Read <5>:                              MPIR.Net Rationals.  (line 215)
* Read <6>:                              MPIR.Net Floats.     (line 212)
* Read <7>:                              MPIR.Net Floats.     (line 213)
* Read <8>:                              MPIR.Net Floats.     (line 214)
* Reallocate:                            MPIR.Net Integers.   (line  54)
* Reallocate <1>:                        MPIR.Net Floats.     (line  74)
* RelativeDifferenceFrom:                MPIR.Net Floats.     (line 196)
* RemoveFactors:                         MPIR.Net Integers.   (line 353)
* Root:                                  MPIR.Net Integers.   (line 318)
* RoundingMode:                          MPIR.Net Settings.   (line  29)
* Seed:                                  MPIR.Net Random Numbers.
                                                              (line  27)
* Seed <1>:                              MPIR.Net Random Numbers.
                                                              (line  28)
* SetBit:                                MPIR.Net Integers.   (line 209)
* SetTo:                                 MPIR.Net Integers.   (line 107)
* SetTo <1>:                             MPIR.Net Integers.   (line 108)
* SetTo <2>:                             MPIR.Net Integers.   (line 109)
* SetTo <3>:                             MPIR.Net Integers.   (line 110)
* SetTo <4>:                             MPIR.Net Integers.   (line 111)
* SetTo <5>:                             MPIR.Net Integers.   (line 112)
* SetTo <6>:                             MPIR.Net Integers.   (line 113)
* SetTo <7>:                             MPIR.Net Rationals.  (line 131)
* SetTo <8>:                             MPIR.Net Rationals.  (line 132)
* SetTo <9>:                             MPIR.Net Rationals.  (line 133)
* SetTo <10>:                            MPIR.Net Rationals.  (line 134)
* SetTo <11>:                            MPIR.Net Rationals.  (line 135)
* SetTo <12>:                            MPIR.Net Rationals.  (line 136)
* SetTo <13>:                            MPIR.Net Rationals.  (line 137)
* SetTo <14>:                            MPIR.Net Rationals.  (line 138)
* SetTo <15>:                            MPIR.Net Rationals.  (line 139)
* SetTo <16>:                            MPIR.Net Rationals.  (line 141)
* SetTo <17>:                            MPIR.Net Floats.     (line 140)
* SetTo <18>:                            MPIR.Net Floats.     (line 141)
* SetTo <19>:                            MPIR.Net Floats.     (line 142)
* SetTo <20>:                            MPIR.Net Floats.     (line 143)
* SetTo <21>:                            MPIR.Net Floats.     (line 144)
* SetTo <22>:                            MPIR.Net Floats.     (line 145)
* SetTo <23>:                            MPIR.Net Floats.     (line 146)
* SetTo <24>:                            MPIR.Net Floats.     (line 147)
* sgn:                                   C++ Interface Integers.
                                                              (line  63)
* sgn <1>:                               C++ Interface Rationals.
                                                              (line  55)
* sgn <2>:                               C++ Interface Floats.
                                                              (line  96)
* Sign:                                  MPIR.Net Integers.   (line 193)
* Sign <1>:                              MPIR.Net Rationals.  (line 196)
* Sign <2>:                              MPIR.Net Floats.     (line 205)
* Size:                                  MPIR.Net Integers.   (line  60)
* sqrt:                                  C++ Interface Integers.
                                                              (line  64)
* sqrt <1>:                              C++ Interface Floats.
                                                              (line  97)
* SquareRoot:                            MPIR.Net Integers.   (line 312)
* SquareRoot <1>:                        MPIR.Net Floats.     (line 200)
* SquareRoot <2>:                        MPIR.Net Floats.     (line 201)
* swap:                                  C++ Interface Integers.
                                                              (line  66)
* swap <1>:                              C++ Interface Rationals.
                                                              (line  57)
* swap <2>:                              C++ Interface Floats.
                                                              (line  99)
* Swap:                                  MPIR.Net Integers.   (line 117)
* Swap <1>:                              MPIR.Net Rationals.  (line 146)
* Swap <2>:                              MPIR.Net Floats.     (line 151)
* ToDouble:                              MPIR.Net Integers.   (line  93)
* ToDouble <1>:                          MPIR.Net Integers.   (line  94)
* ToDouble <2>:                          MPIR.Net Rationals.  (line 120)
* ToDouble <3>:                          MPIR.Net Floats.     (line 126)
* ToDouble <4>:                          MPIR.Net Floats.     (line 127)
* ToInt:                                 MPIR.Net Integers.   (line  89)
* ToInt <1>:                             MPIR.Net Floats.     (line 122)
* ToLong:                                MPIR.Net Integers.   (line  91)
* ToLong <1>:                            MPIR.Net Floats.     (line 124)
* ToString:                              MPIR.Net Integers.   (line  76)
* ToString <1>:                          MPIR.Net Integers.   (line  77)
* ToString <2>:                          MPIR.Net Integers.   (line  78)
* ToString <3>:                          MPIR.Net Rationals.  (line 107)
* ToString <4>:                          MPIR.Net Rationals.  (line 108)
* ToString <5>:                          MPIR.Net Rationals.  (line 109)
* ToString <6>:                          MPIR.Net Floats.     (line 108)
* ToString <7>:                          MPIR.Net Floats.     (line 109)
* ToString <8>:                          MPIR.Net Floats.     (line 110)
* ToString <9>:                          MPIR.Net Floats.     (line 111)
* ToStringDigits:                        MPIR.Net Settings.   (line  35)
* ToUint:                                MPIR.Net Integers.   (line  90)
* ToUint <1>:                            MPIR.Net Floats.     (line 123)
* ToUlong:                               MPIR.Net Integers.   (line  92)
* ToUlong <1>:                           MPIR.Net Floats.     (line 125)
* trunc:                                 C++ Interface Floats.
                                                              (line 100)
* Truncate:                              MPIR.Net Floats.     (line 204)
* USABLE_BITS_PER_LIMB:                  MPIR.Net Settings.   (line  19)
* Value:                                 MPIR.Net Integers.   (line  99)
* Value <1>:                             MPIR.Net Rationals.  (line 123)
* Value <2>:                             MPIR.Net Floats.     (line 132)
* Write:                                 MPIR.Net Integers.   (line 260)
* Write <1>:                             MPIR.Net Integers.   (line 265)
* Write <2>:                             MPIR.Net Integers.   (line 266)
* Write <3>:                             MPIR.Net Integers.   (line 267)
* Write <4>:                             MPIR.Net Rationals.  (line 206)
* Write <5>:                             MPIR.Net Rationals.  (line 211)
* Write <6>:                             MPIR.Net Rationals.  (line 212)
* Write <7>:                             MPIR.Net Rationals.  (line 213)
* Write <8>:                             MPIR.Net Floats.     (line 208)
* Write <9>:                             MPIR.Net Floats.     (line 209)
* Write <10>:                            MPIR.Net Floats.     (line 210)

